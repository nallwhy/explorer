searchNodes=[{"doc":"Explorer brings series (one-dimensional) and dataframes (two-dimensional) for fast data exploration to Elixir. Most of the functionality in Explorer is in Explorer.DataFrame and Explorer.Series . Refer to those modules for more in-depth documentation.","ref":"Explorer.html","title":"Explorer","type":"module"},{"doc":"The DataFrame struct and API. Dataframes are two-dimensional tabular data structures similar to a spreadsheet. For example, the Iris dataset: iex&gt; Explorer.Datasets . iris ( ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; This dataframe has 150 rows and five columns. Each column is an Explorer.Series of the same size (150): iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; df [ &quot;sepal_length&quot; ] # Explorer.Series &lt; Polars [ 150 ] float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , 5.4 , 4.6 , 5.0 , 4.4 , 4.9 , 5.4 , 4.8 , 4.8 , 4.3 , 5.8 , 5.7 , 5.4 , 5.1 , 5.7 , 5.1 , 5.4 , 5.1 , 4.6 , 5.1 , 4.8 , 5.0 , 5.0 , 5.2 , 5.2 , 4.7 , 4.8 , 5.4 , 5.2 , 5.5 , 4.9 , 5.0 , 5.5 , 4.9 , 4.4 , 5.1 , 5.0 , 4.5 , 4.4 , 5.0 , 5.1 , 4.8 , 5.1 , 4.6 , 5.3 , 5.0 , ... ] &gt; Creating dataframes Dataframes can be created from normal Elixir objects. The main way you might do this is with the new/1 function. For example: iex&gt; Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; ] , b : [ 1 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; ] b integer [ 1 , 2 ] &gt; Or with a list of maps: iex&gt; Explorer.DataFrame . new ( [ %{ &quot;col1&quot; =&gt; &quot;a&quot; , &quot;col2&quot; =&gt; 1 } , %{ &quot;col1&quot; =&gt; &quot;b&quot; , &quot;col2&quot; =&gt; 2 } ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;a&quot; , &quot;b&quot; ] col2 integer [ 1 , 2 ] &gt; Verbs Explorer uses the idea of a consistent set of SQL-like verbs like dplyr which can help solve common data manipulation challenges. These are split into single table verbs, multiple table verbs, and row-based verbs: Single table verbs Single table verbs are (unsurprisingly) used for manipulating a single dataframe. Those operations typically driven by column names. These are: select/3 for picking variables filter/2 for picking rows based on predicates mutate/2 for adding or replacing columns that are functions of existing columns arrange/2 for changing the ordering of rows distinct/2 for picking unique rows summarise/2 for reducing multiple rows down to a single summary pivot_longer/3 and pivot_wider/4 for massaging dataframes into longer or wider forms, respectively Each of these combine with Explorer.DataFrame.group_by/2 for operating by group. For more flexibility we also have functions that accept callback functions: filter_with/2 summarise_with/2 mutate_with/2 arrange_with/2 Those functions work by having a &quot;lazy&quot; representation of the dataframe and series, which adds the possibility to perform complex operations that are optimized by the backend. Multiple table verbs Multiple table verbs are used for combining tables. These are: join/3 for performing SQL-like joins concat_rows/1 for vertically &quot;stacking&quot; dataframes concat_columns/1 for horizontally &quot;stacking&quot; dataframes Row-based verbs Those operations are driven by the row index. These are: head/2 for picking the first rows tail/2 for picking the last rows slice/2 for slicing the dataframe by row indexes or a range slice/3 for slicing a section by an offset sample/2 for sampling the data-frame by row IO Explorer supports reading and writing of: delimited files (such as CSV) Parquet Arrow IPC Arrow Streaming IPC Newline Delimited JSON The convention Explorer uses is to have from_* and to_* functions to read and write to files in the formats above. load_* and dump_* versions are also available to read and write those formats directly in memory. Access In addition to this &quot;grammar&quot; of data manipulation, you'll find useful functions for slicing and dicing dataframes such as pull/2 , head/2 , sample/3 , slice/2 , and slice/3 . Explorer.DataFrame also implements the Access behaviour (also known as the brackets syntax). This should be familiar for users coming from other language with dataframes such as R or Python. For example: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ &quot;class&quot; ] # Explorer.Series &lt; Polars [ 178 ] integer [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , ... ] &gt;","ref":"Explorer.DataFrame.html","title":"Explorer.DataFrame","type":"module"},{"doc":"Arranges/sorts rows by columns. Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , desc : &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by more than one column sorts them in the order they are entered: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . arrange ( df , asc : &quot;total&quot; , desc : &quot;country&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2011 , 2011 , 2012 , ... ] country string [ &quot;NIUE&quot; , &quot;TUVALU&quot; , &quot;TUVALU&quot; , &quot;NIUE&quot; , &quot;NIUE&quot; , ... ] total integer [ 1 , 2 , 2 , 2 , 2 , ... ] solid_fuel integer [ 0 , 0 , 0 , 0 , 0 , ... ] liquid_fuel integer [ 1 , 2 , 2 , 2 , 2 , ... ] gas_fuel integer [ 0 , 0 , 0 , 0 , 0 , ... ] cement integer [ 0 , 0 , 0 , 0 , 0 , ... ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 , ... ] per_capita float [ 0.52 , 0.0 , 0.0 , 1.04 , 1.04 , ... ] bunker_fuels integer [ 0 , 0 , 0 , 0 , 0 , ... ] &gt; Alternatively you can pass a callback to sort by the given columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , &amp; String . starts_with? ( &amp;1 , &quot;a&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; Or a callback to sort the columns of a given type: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , fn _name , type -&gt; type == :string end ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; Grouped examples When used in a grouped dataframe, arrange is going to sort each group individually and then return the entire dataframe with the existing groups. If one of the arrange columns is also a group, the sorting for that column is not going to work. It is necessary to first summarise the desired column and then arrange it. Here is an example using the Iris dataset. We group by species and then we try to sort the dataframe by species and petal length, but only &quot;petal length&quot; is taken into account because &quot;species&quot; is a group. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . arrange ( grouped , desc : &quot;species&quot; , asc : &quot;sepal_width&quot; ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.5 , 4.4 , 4.9 , 4.8 , 4.3 , ... ] sepal_width float [ 2.3 , 2.9 , 3.0 , 3.0 , 3.0 , ... ] petal_length float [ 1.3 , 1.4 , 1.4 , 1.4 , 1.1 , ... ] petal_width float [ 0.3 , 0.2 , 0.2 , 0.1 , 0.1 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#arrange/2","title":"Explorer.DataFrame.arrange/2","type":"function"},{"doc":"Arranges/sorts rows by columns using a callback function. Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange_with ( df , &amp; ( &amp;1 [ &quot;a&quot; ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange_with ( df , &amp; [ desc : &amp;1 [ &quot;a&quot; ] ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by more than one column sorts them in the order they are entered: iex&gt; df = Explorer.DataFrame . new ( a : [ 3 , 1 , 3 ] , b : [ 2 , 1 , 3 ] ) iex&gt; Explorer.DataFrame . arrange_with ( df , &amp; [ desc : &amp;1 [ &quot;a&quot; ] , asc : &amp;1 [ &quot;b&quot; ] ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 3 , 3 , 1 ] b integer [ 2 , 3 , 1 ] &gt; Grouped examples When used in a grouped dataframe, arrange_with/2 is going to sort each group individually and then return the entire dataframe with the existing groups. Therefore, if you attempt to arrange a grouped column, it won't have any effect and work as no-op. It is necessary to first summarise the desired column and then arrange it. Here is an example using the Iris dataset. We group by species and then we try to sort the dataframe by species and petal length, but only &quot;petal length&quot; is taken into account because &quot;species&quot; is a group. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . arrange_with ( grouped , &amp; [ desc : &amp;1 [ &quot;species&quot; ] , asc : &amp;1 [ &quot;sepal_width&quot; ] ] ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.5 , 4.4 , 4.9 , 4.8 , 4.3 , ... ] sepal_width float [ 2.3 , 2.9 , 3.0 , 3.0 , 3.0 , ... ] petal_length float [ 1.3 , 1.4 , 1.4 , 1.4 , 1.1 , ... ] petal_width float [ 0.3 , 0.2 , 0.2 , 0.1 , 0.1 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#arrange_with/2","title":"Explorer.DataFrame.arrange_with/2","type":"function"},{"doc":"This collects the lazy data frame into an eager one, computing the query. If already eager, this is a noop. Collecting a grouped dataframe should return a grouped dataframe.","ref":"Explorer.DataFrame.html#collect/1","title":"Explorer.DataFrame.collect/1","type":"function"},{"doc":"Combine two or more dataframes column-wise. Dataframes must have the same number of rows. Examples iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( z : [ 4 , 5 , 6 ] , a : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_columns ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 4 ] x integer [ 1 , 2 , 3 ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] z integer [ 4 , 5 , 6 ] a string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Conflicting names are suffixed with the index of the dataframe in the array: iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4 , 5 , 6 ] , a : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_columns ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 4 ] x integer [ 1 , 2 , 3 ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] x_1 integer [ 4 , 5 , 6 ] a string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt;","ref":"Explorer.DataFrame.html#concat_columns/1","title":"Explorer.DataFrame.concat_columns/1","type":"function"},{"doc":"Combine two dataframes column-wise. concat_columns(df1, df2) is equivalent to concat_columns([df1, df2]) .","ref":"Explorer.DataFrame.html#concat_columns/2","title":"Explorer.DataFrame.concat_columns/2","type":"function"},{"doc":"Combine two or more dataframes row-wise (stack). Column names and dtypes must match. The only exception is for numeric columns that can be mixed together, and casted automatically to float columns. Examples iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4 , 5 , 6 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 2 ] x integer [ 1 , 2 , 3 , 4 , 5 , ... ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt; iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4.2 , 5.3 , 6.4 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 2 ] x float [ 1.0 , 2.0 , 3.0 , 4.2 , 5.3 , ... ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#concat_rows/1","title":"Explorer.DataFrame.concat_rows/1","type":"function"},{"doc":"Combine two dataframes row-wise. concat_rows(df1, df2) is equivalent to concat_rows([df1, df2]) .","ref":"Explorer.DataFrame.html#concat_rows/2","title":"Explorer.DataFrame.concat_rows/2","type":"function"},{"doc":"Takes distinct rows by a selection of columns. Distinct is not affected by groups, although groups are kept in the columns selection if keep_all option is false (the default). Options keep_all - If set to true , keep all columns. Default is false . Examples By default will return unique values of the requested columns: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 2 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] &gt; If keep_all is set to true , then the first value of each column not in the requested columns will be returned: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] , keep_all : true ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; A callback on the dataframe's names can be passed instead of a list (like select/3 ): iex&gt; df = Explorer.DataFrame . new ( x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . distinct ( df , &amp; String . starts_with? ( &amp;1 , &quot;x&quot; ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt; If the dataframe has groups, then the columns of each group will be added to the distinct columns: iex&gt; df = Explorer.DataFrame . new ( x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] ) iex&gt; df = Explorer.DataFrame . group_by ( df , &quot;x1&quot; ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;x2&quot; ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] Groups : [ &quot;x1&quot; ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#distinct/3","title":"Explorer.DataFrame.distinct/3","type":"function"},{"doc":"Drop nil values. Optionally accepts a subset of columns. Examples To drop nils on all columns: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] a integer [ 1 ] b integer [ 1 ] &gt; To select some columns: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5 , 6 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , [ :a , :c ] ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] a integer [ 2 ] b integer [ nil ] c integer [ 5 ] &gt; To select some columns by range: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5 , 6 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , 0 .. 1 ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] a integer [ 1 ] b integer [ 1 ] c integer [ nil ] &gt; Or to select columns by a callback on the names: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5 , 6 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , fn name -&gt; name == &quot;a&quot; or name == &quot;b&quot; end ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] a integer [ 1 ] b integer [ 1 ] c integer [ nil ] &gt; Or to select columns by a callback on the names and types: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5.0 , 6.0 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , fn _name , type -&gt; type == :float end ) # Explorer.DataFrame &lt; Polars [ 2 x 3 ] a integer [ 2 , nil ] b integer [ nil , 3 ] c float [ 5.0 , 6.0 ] &gt;","ref":"Explorer.DataFrame.html#drop_nil/2","title":"Explorer.DataFrame.drop_nil/2","type":"function"},{"doc":"Gets the dtypes of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . dtypes ( df ) %{ &quot;floats&quot; =&gt; :float , &quot;ints&quot; =&gt; :integer }","ref":"Explorer.DataFrame.html#dtypes/1","title":"Explorer.DataFrame.dtypes/1","type":"function"},{"doc":"Turns a set of columns to dummy variables. Examples To mark a single column as dummy: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a_a integer [ 1 , 0 , 1 , 0 ] a_b integer [ 0 , 1 , 0 , 0 ] a_c integer [ 0 , 0 , 0 , 1 ] &gt; Or multiple columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , [ &quot;a&quot; , &quot;b&quot; ] ) # Explorer.DataFrame &lt; Polars [ 4 x 6 ] a_a integer [ 1 , 0 , 1 , 0 ] a_b integer [ 0 , 1 , 0 , 0 ] a_c integer [ 0 , 0 , 0 , 1 ] b_a integer [ 0 , 1 , 0 , 0 ] b_b integer [ 1 , 0 , 1 , 0 ] b_d integer [ 0 , 0 , 0 , 1 ] &gt; Or all string columns: iex&gt; df = Explorer.DataFrame . new ( num : [ 1 , 2 , 3 , 4 ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , fn _name , type -&gt; type == :string end ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] b_a integer [ 0 , 1 , 0 , 0 ] b_b integer [ 1 , 0 , 1 , 0 ] b_d integer [ 0 , 0 , 0 , 1 ] &gt;","ref":"Explorer.DataFrame.html#dummies/2","title":"Explorer.DataFrame.dummies/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of a delimited file. Options header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df |&gt; Explorer.DataFrame . head ( 2 ) |&gt; Explorer.DataFrame . dump_csv ( ) &quot;year,country,total,solid_fuel,liquid_fuel,gas_fuel,cement,gas_flaring,per_capita,bunker_fuels \\n 2010,AFGHANISTAN,2308,627,1601,74,5,0,0.08,9 \\n 2010,ALBANIA,1254,117,953,7,177,0,0.43,7 \\n &quot;","ref":"Explorer.DataFrame.html#dump_csv/2","title":"Explorer.DataFrame.dump_csv/2","type":"function"},{"doc":"Picks rows based on a callback function. This function is efficient because it uses a representation of the series without pulling them. The only restriction is that you need to use a function that returns boolean. But you can also use window functions and aggregations inside comparisons. Notice that grouped dataframes may have different results than ungrouped ones, because the filtering is computed withing groups. Examples iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , &amp; Explorer.Series . greater ( &amp;1 [ &quot;col2&quot; ] , 2 ) ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;c&quot; ] col2 integer [ 3 ] &gt; iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . equal ( df [ &quot;col1&quot; ] , &quot;b&quot; ) end ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;b&quot; ] col2 integer [ 2 ] &gt; iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . cumulative_max ( df [ &quot;col2&quot; ] ) end ) ** (ArgumentError) expecting the function to return a boolean LazySeries, but instead it returned a LazySeries of type :integer But it's possible to use a boolean operation based on another function: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . equal ( Explorer.Series . cumulative_max ( df [ &quot;col2&quot; ] ) , 1 ) end ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;a&quot; ] col2 integer [ 1 ] &gt; Filtering with aggregations have different results if the dataframe is using groups or not: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] , col2 : [ 1 , 2 , 3 , 4 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . greater ( df [ &quot;col2&quot; ] , Explorer.Series . mean ( df [ &quot;col2&quot; ] ) ) end ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;b&quot; , &quot;b&quot; ] col2 integer [ 3 , 4 ] &gt; Grouped examples In a grouped dataframe, the aggregation is calculated within each group. In the following example we select the flowers of the Iris dataset that have the &quot;petal length&quot; above the average of each species group. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . filter_with ( grouped , &amp; Explorer.Series . greater ( &amp;1 [ &quot;petal_length&quot; ] , Explorer.Series . mean ( &amp;1 [ &quot;petal_length&quot; ] ) ) ) # Explorer.DataFrame &lt; Polars [ 79 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.6 , 5.4 , 5.0 , 4.9 , 5.4 , ... ] sepal_width float [ 3.1 , 3.9 , 3.4 , 3.1 , 3.7 , ... ] petal_length float [ 1.5 , 1.7 , 1.5 , 1.5 , 1.5 , ... ] petal_width float [ 0.2 , 0.4 , 0.2 , 0.1 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#filter_with/2","title":"Explorer.DataFrame.filter_with/2","type":"function"},{"doc":"Reads a delimited file into a dataframe. If the CSV is compressed, it is automatically decompressed. Options delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A list/map of {&quot;column_name&quot;, dtype} tuples. Any non-specified column has its type imputed from the first 1000 rows. (default: [] ) header - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: nil ) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) columns - A list of column names or indexes to keep. If present, only these columns are read into the dataframe. (default: nil ) infer_schema_length Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ). parse_dates - Automatically try to parse dates/ datetimes and time. If parsing fails, columns remain of dtype string","ref":"Explorer.DataFrame.html#from_csv/2","title":"Explorer.DataFrame.from_csv/2","type":"function"},{"doc":"Similar to from_csv/2 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#from_csv!/2","title":"Explorer.DataFrame.from_csv!/2","type":"function"},{"doc":"Reads an IPC file into a dataframe. Options columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#from_ipc/2","title":"Explorer.DataFrame.from_ipc/2","type":"function"},{"doc":"Similar to from_ipc/2 but raises if there is a problem reading the IPC file.","ref":"Explorer.DataFrame.html#from_ipc!/2","title":"Explorer.DataFrame.from_ipc!/2","type":"function"},{"doc":"Reads an IPC Streaming file into a dataframe. Options columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#from_ipc_stream/2","title":"Explorer.DataFrame.from_ipc_stream/2","type":"function"},{"doc":"Similar to from_ipc_stream/2 but raises if there is a problem reading the IPC Stream file.","ref":"Explorer.DataFrame.html#from_ipc_stream!/2","title":"Explorer.DataFrame.from_ipc_stream!/2","type":"function"},{"doc":"Read a file of JSON objects or lists separated by new lines Options batch_size - Sets the batch size for reading rows. This value may have significant impact in performance, so adjust it for your needs (default: 1000 ). infer_schema_length - Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ).","ref":"Explorer.DataFrame.html#from_ndjson/2","title":"Explorer.DataFrame.from_ndjson/2","type":"function"},{"doc":"Reads a parquet file into a dataframe.","ref":"Explorer.DataFrame.html#from_parquet/2","title":"Explorer.DataFrame.from_parquet/2","type":"function"},{"doc":"Group the dataframe by one or more variables. When the dataframe has grouping variables, operations are performed per group. Explorer.DataFrame.ungroup/2 removes grouping. Examples You can group by a single variable: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , &quot;country&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;country&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or you can group by multiple: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;country&quot; , &quot;year&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt;","ref":"Explorer.DataFrame.html#group_by/2","title":"Explorer.DataFrame.group_by/2","type":"function"},{"doc":"Returns the groups of a dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , &quot;country&quot; ) iex&gt; Explorer.DataFrame . groups ( df ) [ &quot;country&quot; ] iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; Explorer.DataFrame . groups ( df ) [ ]","ref":"Explorer.DataFrame.html#groups/1","title":"Explorer.DataFrame.groups/1","type":"function"},{"doc":"Returns the first n rows of the dataframe. By default it returns the first 5 rows. If the dataframe is using groups, then the first n rows of each group is returned. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df ) # Explorer.DataFrame &lt; Polars [ 5 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 ] cement integer [ 5 , 177 , 2598 , 0 , 204 ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; ] total integer [ 2308 , 1254 ] solid_fuel integer [ 627 , 117 ] liquid_fuel integer [ 1601 , 953 ] gas_fuel integer [ 74 , 7 ] cement integer [ 5 , 177 ] gas_flaring integer [ 0 , 0 ] per_capita float [ 0.08 , 0.43 ] bunker_fuels integer [ 9 , 7 ] &gt; Grouped examples Using grouped dataframes makes head/2 return n rows from each group. Here is an example using the Iris dataset, and returning two rows from each group: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . head ( grouped , 2 ) # Explorer.DataFrame &lt; Polars [ 6 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 7.0 , 6.4 , 6.3 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.2 , 3.3 , ... ] petal_length float [ 1.4 , 1.4 , 4.7 , 4.5 , 6.0 , ... ] petal_width float [ 0.2 , 0.2 , 1.4 , 1.5 , 2.5 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#head/2","title":"Explorer.DataFrame.head/2","type":"function"},{"doc":"Join two tables. Join types inner - Returns all rows from left where there are matching values in right , and all columns from left and right . left - Returns all rows from left and all columns from left and right . Rows in left with no match in right will have nil values in the new columns. right - Returns all rows from right and all columns from left and right . Rows in right with no match in left will have nil values in the new columns. outer - Returns all rows and all columns from both left and right . Where there are not matching values, returns nil for the one missing. cross - Also known as a cartesian join. Returns all combinations of left and right . Can be very computationally expensive. Options on - The columns to join on. Defaults to overlapping columns. Does not apply to cross join. how - One of the join types (as an atom) described above. Defaults to :inner . Examples Inner join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Left join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :left ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a integer [ 1 , 2 , 2 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Right join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 4 ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] b string [ &quot;a&quot; , &quot;b&quot; , nil ] &gt; Outer join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :outer ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a integer [ 1 , 2 , 4 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , nil , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Cross join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :cross ) # Explorer.DataFrame &lt; Polars [ 9 x 4 ] a integer [ 1 , 1 , 1 , 2 , 2 , ... ] b string [ &quot;a&quot; , &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , ... ] a_right integer [ 1 , 2 , 4 , 1 , 2 , ... ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt; Inner join with different names: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( d : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , on : [ { &quot;a&quot; , &quot;d&quot; } ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt;","ref":"Explorer.DataFrame.html#join/3","title":"Explorer.DataFrame.join/3","type":"function"},{"doc":"Picks rows based on a list or series of values. Examples This function must only be used when you need to select rows based on external values that are not available to the dataframe. For example, you can pass a list: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mask ( df , [ false , true , false ] ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;b&quot; ] col2 integer [ 2 ] &gt; You must avoid using masks when the masks themselves are computed from other columns. For example, DO NOT do this: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mask ( df , Explorer.Series . greater ( df [ &quot;col2&quot; ] , 1 ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;b&quot; , &quot;c&quot; ] col2 integer [ 2 , 3 ] &gt; Instead, do this: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . greater ( df [ &quot;col2&quot; ] , 1 ) end ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;b&quot; , &quot;c&quot; ] col2 integer [ 2 , 3 ] &gt; The filter_with/2 version is much more efficient because it doesn't need to create intermediate series representations to apply the mask.","ref":"Explorer.DataFrame.html#mask/2","title":"Explorer.DataFrame.mask/2","type":"function"},{"doc":"Creates and modifies columns. Columns are added with keyword list or maps. New variables overwrite existing variables of the same name. Column names are coerced from atoms to strings. Examples You can pass in a list directly as a new column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can pass in a series: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; s = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : s ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; You can overwrite existing columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] &gt; Scalar values are repeated to fill the series: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : 4 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 4 , 4 , 4 ] b integer [ 1 , 2 , 3 ] &gt; Alternatively, all of the above works with a map instead of a keyword list: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , %{ &quot;c&quot; =&gt; [ 4 , 5 , 6 ] } ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt;","ref":"Explorer.DataFrame.html#mutate/2","title":"Explorer.DataFrame.mutate/2","type":"function"},{"doc":"Creates or modifies columns using a callback function. This function is similar to mutate/2 , but allows complex operations to be performed, since it uses a virtual representation of the dataframe. The only requirement is that a series operation is returned. New variables overwrite existing variables of the same name. Column names are coerced from atoms to strings. When the dataframe is grouped, a mutation will have the context of that group or groups. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ 4 , 5 , 6 ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , &amp; [ c : Explorer.Series . add ( &amp;1 [ &quot;a&quot; ] , &amp;1 [ &quot;b&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] c integer [ 5 , 7 , 9 ] &gt; You can overwrite existing columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , &amp; [ b : Explorer.Series . pow ( &amp;1 [ &quot;b&quot; ] , 2 ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b float [ 1.0 , 4.0 , 9.0 ] &gt; Scalar values are repeated to fill the series: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , &amp; [ a : Explorer.Series . max ( &amp;1 [ &quot;b&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 3 , 3 , 3 ] b integer [ 1 , 2 , 3 ] &gt; Alternatively, all of the above works with a map instead of a keyword list: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , fn df -&gt; %{ &quot;c&quot; =&gt; Explorer.Series . window_mean ( df [ &quot;b&quot; ] , 2 ) } end ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c float [ 1.0 , 1.5 , 2.5 ] &gt; Grouped examples Mutations in grouped dataframes takes the context of the group. For example, if we want to count how many elements of a given group, we can add a new column with that: iex&gt; df = Explorer.DataFrame . new ( id : [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , :id ) iex&gt; Explorer.DataFrame . mutate_with ( grouped , &amp; [ count : Explorer.Series . count ( &amp;1 [ &quot;b&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] Groups : [ &quot;id&quot; ] id string [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; ] b integer [ 1 , 2 , 3 ] count integer [ 2 , 2 , 1 ] &gt; In case we want to get the average size of the petal length from the Iris dataset, we can: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . mutate_with ( grouped , &amp; [ petal_length_avg : Explorer.Series . mean ( &amp;1 [ &quot;petal_length&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 150 x 6 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] petal_length_avg float [ 1.4640000000000004 , 1.4640000000000004 , 1.4640000000000004 , 1.4640000000000004 , 1.4640000000000004 , ... ] &gt;","ref":"Explorer.DataFrame.html#mutate_with/2","title":"Explorer.DataFrame.mutate_with/2","type":"function"},{"doc":"Returns the number of columns in the dataframe. This function works the same way for grouped dataframes. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_columns ( df ) 10","ref":"Explorer.DataFrame.html#n_columns/1","title":"Explorer.DataFrame.n_columns/1","type":"function"},{"doc":"Returns the number of rows in the dataframe. This function works the same way for grouped dataframes, considering the entire dataframe in the counting of rows. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_rows ( df ) 1094","ref":"Explorer.DataFrame.html#n_rows/1","title":"Explorer.DataFrame.n_rows/1","type":"function"},{"doc":"Gets the names of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . names ( df ) [ &quot;floats&quot; , &quot;ints&quot; ]","ref":"Explorer.DataFrame.html#names/1","title":"Explorer.DataFrame.names/1","type":"function"},{"doc":"Creates a new dataframe. Accepts any tabular data adhering to the Table.Reader protocol, as well as a map or a keyword list with series. Options backend - The Explorer backend to use. Defaults to the value returned by Explorer.Backend.get/0 . Examples From series: iex&gt; Explorer.DataFrame . new ( %{ floats : Explorer.Series . from_list ( [ 1.0 , 2.0 ] ) , ints : Explorer.Series . from_list ( [ 1 , nil ] ) } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; From columnar data: iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , &quot;wrong&quot; ] } ) ** (ArgumentError) cannot create series &quot;ints&quot;: the value &quot;wrong&quot; does not match the inferred series dtype :integer From row data: iex&gt; rows = [ %{ id : 1 , name : &quot;José&quot; } , %{ id : 2 , name : &quot;Christopher&quot; } , %{ id : 3 , name : &quot;Cristine&quot; } ] iex&gt; Explorer.DataFrame . new ( rows ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] id integer [ 1 , 2 , 3 ] name string [ &quot;José&quot; , &quot;Christopher&quot; , &quot;Cristine&quot; ] &gt; iex&gt; rows = [ [ id : 1 , name : &quot;José&quot; ] , [ id : 2 , name : &quot;Christopher&quot; ] , [ id : 3 , name : &quot;Cristine&quot; ] ] iex&gt; Explorer.DataFrame . new ( rows ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] id integer [ 1 , 2 , 3 ] name string [ &quot;José&quot; , &quot;Christopher&quot; , &quot;Cristine&quot; ] &gt;","ref":"Explorer.DataFrame.html#new/2","title":"Explorer.DataFrame.new/2","type":"function"},{"doc":"Pivot data from wide to long. Explorer.DataFrame.pivot_longer/3 &quot;lengthens&quot; data, increasing the number of rows and decreasing the number of columns. The inverse transformation is Explorer.DataFrame.pivot_wider/4 . The second argument ( columns_to_pivot ) can be either an array of column names to pivot or a filter callback on the dataframe's names. These columns must always have the same data type. Options keep - Columns that are not in the list of pivot and should be kept in the dataframe. May be a filter callback on the dataframe's column names. Defaults to all columns except the ones to pivot. drop - Columns that are not in the list of pivot and should be dropped from the dataframe. May be a filter callback on the dataframe's column names. This list of columns is going to be subtracted from the list of keep . Defaults to an empty list. names_to - A string specifying the name of the column to create from the data stored in the column names of the dataframe. Defaults to &quot;variable&quot; . values_to - A string specifying the name of the column to create from the data stored in series element values. Defaults to &quot;value&quot; . Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3282 x 9 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] variable string [ &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , ... ] value integer [ 627 , 117 , 332 , 0 , 0 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) , keep : [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3282 x 4 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] variable string [ &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , ... ] value integer [ 627 , 117 , 332 , 0 , 0 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;total&quot; ] , keep : [ &quot;year&quot; , &quot;country&quot; ] , drop : [ &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 3 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] variable string [ &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , ... ] value integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;total&quot; ] , keep : [ ] , names_to : &quot;my_var&quot; , values_to : &quot;my_value&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 2 ] my_var string [ &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , ... ] my_value integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] &gt;","ref":"Explorer.DataFrame.html#pivot_longer/3","title":"Explorer.DataFrame.pivot_longer/3","type":"function"},{"doc":"Pivot data from long to wide. Explorer.DataFrame.pivot_wider/4 &quot;widens&quot; data, increasing the number of columns and decreasing the number of rows. The inverse transformation is Explorer.DataFrame.pivot_longer/3 . Due to a restriction upstream, values_from must be a numeric type. Options id_columns - A set of columns that uniquely identifies each observation. Defaults to all columns in data except for the columns specified in names_from and values_from . Typically used when you have redundant variables, i.e. variables whose values are perfectly correlated with existing variables. May accept a filter callback, a list or a range of column names. Default value is 0..-1 . If an empty list is passed, or a range that results in a empty list of column names, it raises an error. ID columns cannot be of the float type and attempting so will raise an error. If you need to use float columns as IDs, you must carefully consider rounding or truncating the column and converting it to integer, as long as doing so preserves the properties of the column. names_prefix - String added to the start of every variable name. This is particularly useful if names_from is a numeric vector and you want to create syntactic variable names. Examples iex&gt; df = Explorer.DataFrame . new ( id : [ 1 , 1 ] , variable : [ &quot;a&quot; , &quot;b&quot; ] , value : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . pivot_wider ( df , &quot;variable&quot; , &quot;value&quot; ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] id integer [ 1 ] a integer [ 1 ] b integer [ 2 ] &gt;","ref":"Explorer.DataFrame.html#pivot_wider/4","title":"Explorer.DataFrame.pivot_wider/4","type":"function"},{"doc":"Extracts a single column as a series. This function is not going to consider groups when pulling series. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , &quot;total&quot; ) # Explorer.Series &lt; Polars [ 1094 ] integer [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , 2 ) # Explorer.Series &lt; Polars [ 1094 ] integer [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt;","ref":"Explorer.DataFrame.html#pull/2","title":"Explorer.DataFrame.pull/2","type":"function"},{"doc":"Renames columns. To apply a function to a subset of columns, see rename_with/3 . Examples You can pass in a list of new names: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , [ &quot;c&quot; , &quot;d&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] c string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] d integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using keyword args: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , a : &quot;first&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using a map: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , %{ &quot;a&quot; =&gt; &quot;first&quot; } ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt;","ref":"Explorer.DataFrame.html#rename/2","title":"Explorer.DataFrame.rename/2","type":"function"},{"doc":"Renames columns with a function. Examples If no columns are specified, it will apply the function to all column names: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] YEAR integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] COUNTRY string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] SOLID_FUEL integer [ 627 , 117 , 332 , 0 , 0 , ... ] LIQUID_FUEL integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] GAS_FUEL integer [ 74 , 7 , 14565 , 0 , 374 , ... ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , ... ] GAS_FLARING integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] PER_CAPITA float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] BUNKER_FUELS integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; A callback can be used to filter the column names that will be renamed, similarly to select/3 : iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . ends_with? ( &amp;1 , &quot;_fuel&quot; ) , &amp; String . trim_trailing ( &amp;1 , &quot;_fuel&quot; ) ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or you can just pass in the list of column names you'd like to apply the function to: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , [ &quot;total&quot; , &quot;cement&quot; ] , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt;","ref":"Explorer.DataFrame.html#rename_with/3","title":"Explorer.DataFrame.rename_with/3","type":"function"},{"doc":"Sample rows from a dataframe. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. Options replacement - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the dataframe or frac &gt; 1.0. (default: false ) seed - An integer to be used as a random seed. If nil, a random value between 1 and 1e12 will be used. (default: nil) Examples You can sample N rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 3 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 3 x 10 ] year integer [ 2012 , 2012 , 2013 ] country string [ &quot;ZIMBABWE&quot; , &quot;NICARAGUA&quot; , &quot;NIGER&quot; ] total integer [ 2125 , 1260 , 529 ] solid_fuel integer [ 917 , 0 , 93 ] liquid_fuel integer [ 1006 , 1176 , 432 ] gas_fuel integer [ 0 , 0 , 0 ] cement integer [ 201 , 84 , 4 ] gas_flaring integer [ 0 , 0 , 0 ] per_capita float [ 0.15 , 0.21 , 0.03 ] bunker_fuels integer [ 9 , 18 , 19 ] &gt; Or you can sample a proportion of rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 0.03 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 33 x 10 ] year integer [ 2013 , 2012 , 2013 , 2012 , 2010 , ... ] country string [ &quot;BAHAMAS&quot; , &quot;POLAND&quot; , &quot;SLOVAKIA&quot; , &quot;MOZAMBIQUE&quot; , &quot;OMAN&quot; , ... ] total integer [ 764 , 81792 , 9024 , 851 , 12931 , ... ] solid_fuel integer [ 1 , 53724 , 3657 , 11 , 0 , ... ] liquid_fuel integer [ 763 , 17353 , 2090 , 632 , 2331 , ... ] gas_fuel integer [ 0 , 8544 , 2847 , 47 , 9309 , ... ] cement integer [ 0 , 2165 , 424 , 161 , 612 , ... ] gas_flaring integer [ 0 , 6 , 7 , 0 , 679 , ... ] per_capita float [ 2.02 , 2.12 , 1.67 , 0.03 , 4.39 , ... ] bunker_fuels integer [ 167 , 573 , 34 , 56 , 1342 , ... ] &gt;","ref":"Explorer.DataFrame.html#sample/3","title":"Explorer.DataFrame.sample/3","type":"function"},{"doc":"Selects a subset of columns by name. Can optionally return all but the named columns if :drop is passed as the last argument. It's important to notice that groups are kept: you can't select off grouping columns. Examples You can select a single column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; Or a list of names: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; You can also use a range or a list of integers: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , [ 0 , 1 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , 0 .. 1 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] &gt; Or you can use a callback function that takes the dataframe's names as its first argument: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , &amp; String . starts_with? ( &amp;1 , &quot;b&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] b integer [ 1 , 2 , 3 ] &gt; Or a callback function that takes names and types: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , fn _name , type -&gt; type == :integer end ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] b integer [ 1 , 2 , 3 ] &gt; If you pass :drop as the third argument, it will return all but the named columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; , &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] c integer [ 4 , 5 , 6 ] &gt; Grouped examples Selecting columns from a grouped dataframe works the same way, except if the column is also a group. Columns that are also groups cannot be removed, so you need to ungroup before removing these columns. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . select ( grouped , [ &quot;sepal_width&quot; ] ) # Explorer.DataFrame &lt; Polars [ 150 x 2 ] Groups : [ &quot;species&quot; ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . select ( grouped , [ &quot;species&quot; ] , :drop ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#select/3","title":"Explorer.DataFrame.select/3","type":"function"},{"doc":"Gets the shape of the dataframe as a {height, width} tuple. This function works the same way for grouped dataframes, considering the entire dataframe in the counting of rows. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 , 3.0 ] , ints : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . shape ( df ) { 3 , 2 }","ref":"Explorer.DataFrame.html#shape/1","title":"Explorer.DataFrame.shape/1","type":"function"},{"doc":"Subset rows with a list of indices or a range. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . slice ( df , [ 0 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 1 , 3 ] b string [ &quot;a&quot; , &quot;c&quot; ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . slice ( df , 1 .. 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 2 , 3 ] b string [ &quot;b&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#slice/2","title":"Explorer.DataFrame.slice/2","type":"function"},{"doc":"Subset a continuous set of rows. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , 1 , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2010 , 2010 ] country string [ &quot;ALBANIA&quot; , &quot;ALGERIA&quot; ] total integer [ 1254 , 32500 ] solid_fuel integer [ 117 , 332 ] liquid_fuel integer [ 953 , 12381 ] gas_fuel integer [ 7 , 14565 ] cement integer [ 177 , 2598 ] gas_flaring integer [ 0 , 2623 ] per_capita float [ 0.43 , 0.9 ] bunker_fuels integer [ 7 , 663 ] &gt; Negative offsets count from the end of the series: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2014 , 2014 ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; ] total integer [ 1432855 , 1840 ] solid_fuel integer [ 450047 , 2 ] liquid_fuel integer [ 576531 , 1700 ] gas_fuel integer [ 390719 , 25 ] cement integer [ 11314 , 112 ] gas_flaring integer [ 4244 , 0 ] per_capita float [ 4.43 , 0.54 ] bunker_fuels integer [ 30722 , 251 ] &gt; If the length would run past the end of the dataframe, the result may be shorter than the length: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 20 ) # Explorer.DataFrame &lt; Polars [ 10 x 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 , ... ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; , &quot;UZBEKISTAN&quot; , &quot;VANUATU&quot; , &quot;VENEZUELA&quot; , ... ] total integer [ 1432855 , 1840 , 28692 , 42 , 50510 , ... ] solid_fuel integer [ 450047 , 2 , 1677 , 0 , 204 , ... ] liquid_fuel integer [ 576531 , 1700 , 2086 , 42 , 28445 , ... ] gas_fuel integer [ 390719 , 25 , 23929 , 0 , 12731 , ... ] cement integer [ 11314 , 112 , 1000 , 0 , 1088 , ... ] gas_flaring integer [ 4244 , 0 , 0 , 0 , 8042 , ... ] per_capita float [ 4.43 , 0.54 , 0.97 , 0.16 , 1.65 , ... ] bunker_fuels integer [ 30722 , 251 , 0 , 10 , 1256 , ... ] &gt;","ref":"Explorer.DataFrame.html#slice/3","title":"Explorer.DataFrame.slice/3","type":"function"},{"doc":"Summarise each group to a single row. Implicitly ungroups. Supported operations The following aggregations may be performed: :min - Take the minimum value within the group. See Explorer.Series.min/1 . :max - Take the maximum value within the group. See Explorer.Series.max/1 . :sum - Take the sum of the series within the group. See Explorer.Series.sum/1 . :mean - Take the mean of the series within the group. See Explorer.Series.mean/1 . :median - Take the median of the series within the group. See Explorer.Series.median/1 . :first - Take the first value within the group. See Explorer.Series.first/1 . :last - Take the last value within the group. See Explorer.Series.last/1 . :count - Count the number of rows per group. :n_distinct - Count the number of unique rows per group. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df |&gt; Explorer.DataFrame . group_by ( &quot;year&quot; ) |&gt; Explorer.DataFrame . summarise ( total : [ :max , :min ] , country : [ :n_distinct ] ) # Explorer.DataFrame &lt; Polars [ 5 x 4 ] year integer [ 2010 , 2011 , 2012 , 2013 , 2014 ] total_max integer [ 2393248 , 2654360 , 2734817 , 2797384 , 2806634 ] total_min integer [ 1 , 2 , 2 , 2 , 3 ] country_n_distinct integer [ 217 , 217 , 220 , 220 , 220 ] &gt;","ref":"Explorer.DataFrame.html#summarise/2","title":"Explorer.DataFrame.summarise/2","type":"function"},{"doc":"Summarise each group to a single row using a callback function. Implicitly ungroups. The main difference between summarise/2 and summarise_with/2 is that the latter accepts a function that can be used to perform complex operations. This is efficient because it doesn't need to create intermediate series representations to summarise. Supported operations The function callback should be in the form of [name_of_col: &quot;operation&quot;] , where &quot;operation&quot; is one of the Explorer.Series functions. It's required that at least one of the following functions is used for summarisation: Explorer.Series.min/1 - Take the minimum value within the group. Explorer.Series.max/1 - Take the maximum value within the group. Explorer.Series.sum/1 - Take the sum of the series within the group. Explorer.Series.mean/1 - Take the mean of the series within the group. Explorer.Series.median/1 - Take the median of the series within the group. Explorer.Series.first/1 - Take the first value within the group. Explorer.Series.last/1 - Take the last value within the group. Explorer.Series.count/1 - Count the number of rows per group. Explorer.Series.n_distinct/1 - Count the number of unique rows per group. Examples iex&gt; alias Explorer . { DataFrame , Series } iex&gt; df = Explorer.Datasets . fossil_fuels ( ) |&gt; DataFrame . group_by ( &quot;year&quot; ) iex&gt; DataFrame . summarise_with ( df , &amp; [ total_max : Series . max ( &amp;1 [ &quot;total&quot; ] ) , countries : Series . n_distinct ( &amp;1 [ &quot;country&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 5 x 3 ] year integer [ 2010 , 2011 , 2012 , 2013 , 2014 ] total_max integer [ 2393248 , 2654360 , 2734817 , 2797384 , 2806634 ] countries integer [ 217 , 217 , 220 , 220 , 220 ] &gt;","ref":"Explorer.DataFrame.html#summarise_with/2","title":"Explorer.DataFrame.summarise_with/2","type":"function"},{"doc":"Display the DataFrame in a tabular fashion. Examples df = Explorer.Datasets.iris() Explorer.DataFrame.table(df) Explorer.DataFrame.table(df, limit: 1) Explorer.DataFrame.table(df, limit: :infinity)","ref":"Explorer.DataFrame.html#table/2","title":"Explorer.DataFrame.table/2","type":"function"},{"doc":"Returns the last n rows of the dataframe. By default it returns the last 5 rows. If the dataframe is using groups, then the last n rows of each group is returned. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df ) # Explorer.DataFrame &lt; Polars [ 5 x 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 ] country string [ &quot;VIET NAM&quot; , &quot;WALLIS AND FUTUNA ISLANDS&quot; , &quot;YEMEN&quot; , &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 45517 , 6 , 6190 , 1228 , 3278 ] solid_fuel integer [ 19246 , 0 , 137 , 132 , 2097 ] liquid_fuel integer [ 12694 , 6 , 5090 , 797 , 1005 ] gas_fuel integer [ 5349 , 0 , 581 , 0 , 0 ] cement integer [ 8229 , 0 , 381 , 299 , 177 ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 ] per_capita float [ 0.49 , 0.44 , 0.24 , 0.08 , 0.22 ] bunker_fuels integer [ 761 , 1 , 153 , 33 , 9 ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2014 , 2014 ] country string [ &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 1228 , 3278 ] solid_fuel integer [ 132 , 2097 ] liquid_fuel integer [ 797 , 1005 ] gas_fuel integer [ 0 , 0 ] cement integer [ 299 , 177 ] gas_flaring integer [ 0 , 0 ] per_capita float [ 0.08 , 0.22 ] bunker_fuels integer [ 33 , 9 ] &gt; Grouped examples Using grouped dataframes makes tail/2 return n rows from each group. Here is an example using the Iris dataset, and returning two rows from each group: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . tail ( grouped , 2 ) # Explorer.DataFrame &lt; Polars [ 6 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.3 , 5.0 , 5.1 , 5.7 , 6.2 , ... ] sepal_width float [ 3.7 , 3.3 , 2.5 , 2.8 , 3.4 , ... ] petal_length float [ 1.5 , 1.4 , 3.0 , 4.1 , 5.4 , ... ] petal_width float [ 0.2 , 0.2 , 1.1 , 1.3 , 2.3 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#tail/2","title":"Explorer.DataFrame.tail/2","type":"function"},{"doc":"Converts a dataframe to a list of columns with lists as values. See to_series/2 if you want a list of columns with series as values. Note that this function does not take into account groups. Options :atom_keys - Configure if the resultant map should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( ints : [ 1 , nil ] , floats : [ 1.0 , 2.0 ] ) iex&gt; Explorer.DataFrame . to_columns ( df ) %{ &quot;floats&quot; =&gt; [ 1.0 , 2.0 ] , &quot;ints&quot; =&gt; [ 1 , nil ] } iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_columns ( df , atom_keys : true ) %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] }","ref":"Explorer.DataFrame.html#to_columns/2","title":"Explorer.DataFrame.to_columns/2","type":"function"},{"doc":"Writes a dataframe to a delimited file. Groups are ignored if the dataframe is using any. Options header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; )","ref":"Explorer.DataFrame.html#to_csv/3","title":"Explorer.DataFrame.to_csv/3","type":"function"},{"doc":"Similar to to_csv/3 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#to_csv!/3","title":"Explorer.DataFrame.to_csv!/3","type":"function"},{"doc":"Writes a dataframe to an IPC file. Apache IPC is a language-agnostic columnar data structure that can be used to store dataframes. It excels as a format for quickly exchange data between different programming languages. Groups are ignored if the dataframe is using any. Options compression - Sets the algorithm used to compress the IPC file. It accepts :zstd or :lz4 compression. (default: nil )","ref":"Explorer.DataFrame.html#to_ipc/3","title":"Explorer.DataFrame.to_ipc/3","type":"function"},{"doc":"Writes a dataframe to a IPC Stream file. Arrow IPC Streams provide a streaming protocol or “format&quot; for sending an arbitrary length sequence of record batches. The format must be processed from start to end, and does not support random access. You can read more information about the difference between IPC and IPC Streaming files on the [ https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format](Apache Arrow Documentation(#ipc-streaming-format) page. Options compression - Sets the algorithm used to compress the IPC file. It accepts &quot;ZSTD&quot; or &quot;LZ4&quot; compression. (default: nil )","ref":"Explorer.DataFrame.html#to_ipc_stream/3","title":"Explorer.DataFrame.to_ipc_stream/3","type":"function"},{"doc":"Converts the dataframe to the lazy version of the current backend. If already lazy, this is a noop. Converting a grouped dataframe should return a lazy dataframe with groups.","ref":"Explorer.DataFrame.html#to_lazy/1","title":"Explorer.DataFrame.to_lazy/1","type":"function"},{"doc":"Writes a dataframe to a ndjson file. Groups are ignored if the dataframe is using any. NDJSON are files that contains JSON files separated by new lines. They are often used as structured logs.","ref":"Explorer.DataFrame.html#to_ndjson/2","title":"Explorer.DataFrame.to_ndjson/2","type":"function"},{"doc":"Writes a dataframe to a parquet file. Groups are ignored if the dataframe is using any. Options compression - The compression algorithm to use when writing files. Where a compression level is available, this can be passed as a tuple, such as {:zstd, 3} . Supported options are: nil (uncompressed, default) :snappy :gzip (with levels 1-9) :brotli (with levels 1-11) :zstd (with levels -7-22) :lz4raw .","ref":"Explorer.DataFrame.html#to_parquet/3","title":"Explorer.DataFrame.to_parquet/3","type":"function"},{"doc":"Converts a dataframe to a list of maps (rows). Warning This may be an expensive operation because polars stores data in columnar format. Options :atom_keys - Configure if the resultant maps should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows ( df ) [ %{ &quot;floats&quot; =&gt; 1.0 , &quot;ints&quot; =&gt; 1 } , %{ &quot;floats&quot; =&gt; 2.0 , &quot;ints&quot; =&gt; nil } ] iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows ( df , atom_keys : true ) [ %{ floats : 1.0 , ints : 1 } , %{ floats : 2.0 , ints : nil } ]","ref":"Explorer.DataFrame.html#to_rows/2","title":"Explorer.DataFrame.to_rows/2","type":"function"},{"doc":"Converts a dataframe to a list of columns with series as values. See to_columns/2 if you want a list of columns with lists as values. Note that this function does not take into account groups. Options :atom_keys - Configure if the resultant map should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( ints : [ 1 , nil ] , floats : [ 1.0 , 2.0 ] ) iex&gt; map = Explorer.DataFrame . to_series ( df ) iex&gt; Explorer.Series . to_list ( map [ &quot;floats&quot; ] ) [ 1.0 , 2.0 ] iex&gt; Explorer.Series . to_list ( map [ &quot;ints&quot; ] ) [ 1 , nil ]","ref":"Explorer.DataFrame.html#to_series/2","title":"Explorer.DataFrame.to_series/2","type":"function"},{"doc":"Removes grouping variables. Accepts a list of group names. If groups is not specified, then all groups are removed. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) iex&gt; Explorer.DataFrame . ungroup ( df , [ &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;year&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) iex&gt; Explorer.DataFrame . ungroup ( df ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt;","ref":"Explorer.DataFrame.html#ungroup/2","title":"Explorer.DataFrame.ungroup/2","type":"function"},{"doc":"Represents a column name or its index.","ref":"Explorer.DataFrame.html#t:column/0","title":"Explorer.DataFrame.column/0","type":"type"},{"doc":"Represents a column name as atom or string.","ref":"Explorer.DataFrame.html#t:column_name/0","title":"Explorer.DataFrame.column_name/0","type":"type"},{"doc":"Represents multiple column names as atoms or strings.","ref":"Explorer.DataFrame.html#t:column_names/0","title":"Explorer.DataFrame.column_names/0","type":"type"},{"doc":"Represents a column pair where the value is a column name or a column index, and the value is of type value .","ref":"Explorer.DataFrame.html#t:column_pairs/1","title":"Explorer.DataFrame.column_pairs/1","type":"type"},{"doc":"Represents multiple columns. The columns may be specified as one of: a list of columns indexes or names as atoms and strings a range a one-arity function that receives column names and returns true for column names to keep a two-arity function that receives column names and types and returns true for column names to keep","ref":"Explorer.DataFrame.html#t:columns/0","title":"Explorer.DataFrame.columns/0","type":"type"},{"doc":"Represents a dataframe.","ref":"Explorer.DataFrame.html#t:t/0","title":"Explorer.DataFrame.t/0","type":"type"},{"doc":"","ref":"Explorer.Datasets.html","title":"Explorer.Datasets","type":"module"},{"doc":"CO2 emissions from fossil fuels since 2010, by country Citation Boden, T.A., G. Marland, and R.J. Andres. 2013. Global, Regional, and National Fossil-Fuel CO2 Emissions. Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory, U.S. Department of Energy, Oak Ridge, Tenn., U.S.A. doi 10.3334/CDIAC/00001_V2013","ref":"Explorer.Datasets.html#fossil_fuels/0","title":"Explorer.Datasets.fossil_fuels/0","type":"function"},{"doc":"Iris Dataset - This classic dataset was collected by Edgar Anderson in 1936 and made famous by R. A. Fisher's 1936 paper. It consists of several measurements of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data Citation Original Owners: R. A. Fisher (1936) The use of multiple measurements in taxonomic problems. Annals of Eugenics. 7 (2): 179–188. doi:10.1111/j.1469-1809.1936.tb02137.x Iris. (1936). UCI Machine Learning Repository.","ref":"Explorer.Datasets.html#iris/0","title":"Explorer.Datasets.iris/0","type":"function"},{"doc":"Wine Dataset - The data is the result of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars. The analysis determined the quantities of 13 constituents found in each of the three types of wines. Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data Citation Original Owners: Forina, M. et al, PARVUS - An Extendible Package for Data Exploration, Classification and Correlation. Institute of Pharmaceutical and Food Analysis and Technologies, Via Brigata Salerno, 16147 Genoa, Italy. Wine. (1991). UCI Machine Learning Repository.","ref":"Explorer.Datasets.html#wine/0","title":"Explorer.Datasets.wine/0","type":"function"},{"doc":"The Series struct and API. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime A series must consist of a single data type only. Series are nullable, but may not consist only of nils. Many functions only apply to certain dtypes. Where that is the case, you'll find a Supported dtypes section in the function documentation and the function will raise an ArgumentError if a series with an invalid dtype is used.","ref":"Explorer.Series.html","title":"Explorer.Series","type":"module"},{"doc":"Adds right to left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . add ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 5 , 7 , 9 ] &gt; You can also use scalar values on both sides: iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . add ( s1 , 2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . add ( 2 , s1 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#add/2","title":"Explorer.Series.add/2","type":"function"},{"doc":"Checks equality between two entire series. Examples iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . all_equal ( s1 , s2 ) true iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . all_equal ( s1 , s2 ) false iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 ] ) iex&gt; Explorer.Series . all_equal ( s1 , s2 ) false","ref":"Explorer.Series.html#all_equal/2","title":"Explorer.Series.all_equal/2","type":"function"},{"doc":"Returns a boolean mask of left and right , element-wise Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . greater ( s1 , 1 ) iex&gt; mask2 = Explorer.Series . less ( s1 , 3 ) iex&gt; Explorer.Series . and ( mask1 , mask2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , false ] &gt;","ref":"Explorer.Series.html#and/2","title":"Explorer.Series.and/2","type":"function"},{"doc":"Returns the indices that would sort the series.","ref":"Explorer.Series.html#argsort/2","title":"Explorer.Series.argsort/2","type":"function"},{"doc":"Cast the series to another type. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :string ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :float ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 2.0 , 3.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :date ) # Explorer.Series &lt; Polars [ 3 ] date [ 1970 - 01 - 02 , 1970 - 01 - 03 , 1970 - 01 - 04 ] &gt; Note that datetime is represented as an integer of microseconds since Unix Epoch (1970-01-01 00:00:00). iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :datetime ) # Explorer.Series &lt; Polars [ 3 ] datetime [ 1970 - 01 - 01 00 : 00 : 00.000001 , 1970 - 01 - 01 00 : 00 : 00.000002 , 1970 - 01 - 01 00 : 00 : 00.000003 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1649883642 * 1_000 * 1_000 ] ) iex&gt; Explorer.Series . cast ( s , :datetime ) # Explorer.Series &lt; Polars [ 1 ] datetime [ 2022 - 04 - 13 21 : 00 : 42.000000 ] &gt; cast/2 will return the series as a no-op if you try to cast to the same dtype. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :integer ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#cast/2","title":"Explorer.Series.cast/2","type":"function"},{"doc":"Finds the first non-missing element at each position. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , nil , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; s3 = Explorer.Series . from_list ( [ nil , nil , 3 , 4 ] ) iex&gt; Explorer.Series . coalesce ( [ s1 , s2 , s3 ] ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt;","ref":"Explorer.Series.html#coalesce/1","title":"Explorer.Series.coalesce/1","type":"function"},{"doc":"Finds the first non-missing element at each position. coalesce(s1, s2) is equivalent to coalesce([s1, s2]) . Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , nil , 3 , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . coalesce ( s1 , s2 ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ &quot;foo&quot; , nil , &quot;bar&quot; , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . coalesce ( s1 , s2 ) ** (ArgumentError) cannot invoke Explorer.Series.coalesce/2 with mismatched dtypes: string and integer.","ref":"Explorer.Series.html#coalesce/2","title":"Explorer.Series.coalesce/2","type":"function"},{"doc":"Concatenate one or more series. The dtypes must match unless all are numeric, in which case all series will be downcast to float. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . concat ( [ s1 , s2 ] ) # Explorer.Series &lt; Polars [ 6 ] integer [ 1 , 2 , 3 , 4 , 5 , 6 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4.0 , 5.0 , 6.4 ] ) iex&gt; Explorer.Series . concat ( s1 , s2 ) # Explorer.Series &lt; Polars [ 6 ] float [ 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.4 ] &gt;","ref":"Explorer.Series.html#concat/1","title":"Explorer.Series.concat/1","type":"function"},{"doc":"Concatenate one or more series. concat(s1, s2) is equivalent to concat([s1, s2]) .","ref":"Explorer.Series.html#concat/2","title":"Explorer.Series.concat/2","type":"function"},{"doc":"Creates a new dataframe with unique values and the count of each. In the context of lazy series - using DataFrame.*_with/2 functions -, count/1 is going to count the elements inside the same group. If no group is in use, then count is going to return the length of the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . count ( s ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] values string [ &quot;c&quot; , &quot;a&quot; , &quot;b&quot; ] counts integer [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#count/1","title":"Explorer.Series.count/1","type":"function"},{"doc":"Calculates the cumulative maximum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , nil , 4 ] &gt;","ref":"Explorer.Series.html#cumulative_max/2","title":"Explorer.Series.cumulative_max/2","type":"function"},{"doc":"Calculates the cumulative minimum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 1 , 1 , 1 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 1 , nil , 1 ] &gt;","ref":"Explorer.Series.html#cumulative_min/2","title":"Explorer.Series.cumulative_min/2","type":"function"},{"doc":"Calculates the cumulative sum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :boolean Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_sum ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 3 , 6 , 10 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_sum ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 3 , nil , 7 ] &gt;","ref":"Explorer.Series.html#cumulative_sum/2","title":"Explorer.Series.cumulative_sum/2","type":"function"},{"doc":"Returns the unique values of the series. Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . distinct ( ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#distinct/1","title":"Explorer.Series.distinct/1","type":"function"},{"doc":"Divides left by right, element-wise. The resulting series will have the dtype as :float . Supported dtypes :integer :float Examples iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 5.0 , 5.0 , 5.0 ] &gt; iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , 2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 5.0 , 5.0 , 5.0 ] &gt; iex&gt; s1 = [ 10 , 52 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , 2.5 ) # Explorer.Series &lt; Polars [ 3 ] float [ 4.0 , 20.8 , 4.0 ] &gt; iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 0 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 5.0 , infinity , 5.0 ] &gt;","ref":"Explorer.Series.html#divide/2","title":"Explorer.Series.divide/2","type":"function"},{"doc":"Returns the data type of the series. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . dtype ( s ) :integer iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , nil , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . dtype ( s ) :string","ref":"Explorer.Series.html#dtype/1","title":"Explorer.Series.dtype/1","type":"function"},{"doc":"Returns boolean mask of left == right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . equal ( s , 1 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . equal ( s , true ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , &quot;a&quot; ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , false ) ** (ArgumentError) cannot invoke Explorer.Series.equal/2 with mismatched dtypes: string and false.","ref":"Explorer.Series.html#equal/2","title":"Explorer.Series.equal/2","type":"function"},{"doc":"Returns the value of the series at the given index. This function will raise an error in case the index is out of bounds. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . fetch! ( s , 2 ) &quot;c&quot; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . fetch! ( s , 4 ) ** (ArgumentError) index 4 out of bounds for series of size 3","ref":"Explorer.Series.html#fetch!/2","title":"Explorer.Series.fetch!/2","type":"function"},{"doc":"Fill missing values with the given strategy. If a scalar value is provided instead of a strategy atom, nil will be replaced with that value. It must be of the same dtype as the series. Strategies :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :forward ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :backward ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :max ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :min ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 1 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :mean ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3 ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 4.0 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3.0 ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , 3.0 , 4.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , nil , &quot;d&quot; ] ) iex&gt; Explorer.Series . fill_missing ( s , &quot;c&quot; ) # Explorer.Series &lt; Polars [ 4 ] string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , &quot;foo&quot; ) ** (ArgumentError) cannot invoke Explorer.Series.fill_missing/2 with mismatched dtypes: integer and &quot;foo&quot;.","ref":"Explorer.Series.html#fill_missing/2","title":"Explorer.Series.fill_missing/2","type":"function"},{"doc":"Returns the first element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . first ( s ) 1","ref":"Explorer.Series.html#first/1","title":"Explorer.Series.first/1","type":"function"},{"doc":"Creates a new series from a list. The list must consist of a single data type and nils. It is possible to have a list of only nil values. In this case, the list will have the :dtype of float. Options :backend - The backend to allocate the series on. :dtype - Cast the series to a given :dtype . By default this is nil , which means that Explorer will infer the type from the values in the list. Examples Explorer will infer the type from the values in the list. iex&gt; Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt; Series are nullable, so you may also include nils. iex&gt; Explorer.Series . from_list ( [ 1.0 , nil , 2.5 , 3.1 ] ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , nil , 2.5 , 3.1 ] &gt; A mix of integers and floats will be downcasted to a float. iex&gt; Explorer.Series . from_list ( [ 1 , 2.0 ] ) # Explorer.Series &lt; Polars [ 2 ] float [ 1.0 , 2.0 ] &gt; Trying to create a &quot;nil&quot; series will, by default, result in a series of floats. iex&gt; Explorer.Series . from_list ( [ nil , nil ] ) # Explorer.Series &lt; Polars [ 2 ] float [ nil , nil ] &gt; You can specify the desired dtype for a series with the :dtype option. iex&gt; Explorer.Series . from_list ( [ nil , nil ] , dtype : :integer ) # Explorer.Series &lt; Polars [ 2 ] integer [ nil , nil ] &gt; iex&gt; Explorer.Series . from_list ( [ 1 , nil ] , dtype : :string ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;1&quot; , nil ] &gt; It is possible to create a series of :datetime from a list of microseconds since Unix Epoch. iex&gt; Explorer.Series . from_list ( [ 1649883642 * 1_000 * 1_000 ] , dtype : :datetime ) # Explorer.Series &lt; Polars [ 1 ] datetime [ 2022 - 04 - 13 21 : 00 : 42.000000 ] &gt; Mixing non-numeric data types will raise an ArgumentError. iex&gt; Explorer.Series . from_list ( [ 1 , &quot;a&quot; ] ) ** (ArgumentError) the value &quot;a&quot; does not match the inferred series dtype :integer","ref":"Explorer.Series.html#from_list/2","title":"Explorer.Series.from_list/2","type":"function"},{"doc":"Converts a Nx.Tensor.t/0 to a series. Warning Nx is an optional dependency. You will need to ensure it's installed to use this function. Examples iex&gt; tensor = Nx . tensor ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt; iex&gt; tensor = Nx . tensor ( [ 1.0 , 2.0 , 3.0 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#from_tensor/2","title":"Explorer.Series.from_tensor/2","type":"function"},{"doc":"Returns boolean mask of left &gt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , false ] &gt;","ref":"Explorer.Series.html#greater/2","title":"Explorer.Series.greater/2","type":"function"},{"doc":"Returns boolean mask of left &gt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater_equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt;","ref":"Explorer.Series.html#greater_equal/2","title":"Explorer.Series.greater_equal/2","type":"function"},{"doc":"Returns the first N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . head ( s ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt;","ref":"Explorer.Series.html#head/2","title":"Explorer.Series.head/2","type":"function"},{"doc":"Returns a mask of nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . is_nil ( s ) # Explorer.Series &lt; Polars [ 4 ] boolean [ false , false , true , false ] &gt;","ref":"Explorer.Series.html#is_nil/1","title":"Explorer.Series.is_nil/1","type":"function"},{"doc":"Returns a mask of not nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . is_not_nil ( s ) # Explorer.Series &lt; Polars [ 4 ] boolean [ true , true , false , true ] &gt;","ref":"Explorer.Series.html#is_not_nil/1","title":"Explorer.Series.is_not_nil/1","type":"function"},{"doc":"Returns the last element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . last ( s ) 100","ref":"Explorer.Series.html#last/1","title":"Explorer.Series.last/1","type":"function"},{"doc":"Returns boolean mask of left &lt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , true ] &gt;","ref":"Explorer.Series.html#less/2","title":"Explorer.Series.less/2","type":"function"},{"doc":"Returns boolean mask of left &lt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less_equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , true ] &gt;","ref":"Explorer.Series.html#less_equal/2","title":"Explorer.Series.less_equal/2","type":"function"},{"doc":"Filters a series with a mask. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . mask ( s1 , s2 ) # Explorer.Series &lt; Polars [ 2 ] integer [ 1 , 3 ] &gt;","ref":"Explorer.Series.html#mask/2","title":"Explorer.Series.mask/2","type":"function"},{"doc":"Gets the maximum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . max ( s ) 3 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . max ( s ) 3.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . max ( s ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . max ( s ) ~N[2021-01-01 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . max ( s ) ** (ArgumentError) Explorer.Series.max/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#max/1","title":"Explorer.Series.max/1","type":"function"},{"doc":"Gets the mean value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . mean ( s ) ** (ArgumentError) Explorer.Series.mean/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#mean/1","title":"Explorer.Series.mean/1","type":"function"},{"doc":"Gets the median value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . median ( s ) ** (ArgumentError) Explorer.Series.median/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#median/1","title":"Explorer.Series.median/1","type":"function"},{"doc":"Returns the memory type of the series. This function mirrors the Nx types. It returns something in the shape of atom() or {atom(), bits_size} . The possible memtypes are: :utf8 for strings. :u for unsigned integers. :s for signed integers. :f for floats. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;Alice&quot; , &quot;Bob&quot; ] ) iex&gt; Explorer.Series . memtype ( s ) :utf8 iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 ] ) iex&gt; Explorer.Series . memtype ( s ) { :s , 64 } iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . memtype ( s ) { :s , 32 } iex&gt; s = Explorer.Series . from_list ( [ 1.2 , 2.3 , 3.5 , 4.5 ] ) iex&gt; Explorer.Series . memtype ( s ) { :f , 64 } iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . memtype ( s ) { :u , 8 }","ref":"Explorer.Series.html#memtype/1","title":"Explorer.Series.memtype/1","type":"function"},{"doc":"Gets the minimum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . min ( s ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . min ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . min ( s ) ~D[1999-12-31] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . min ( s ) ~N[1999-12-31 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . min ( s ) ** (ArgumentError) Explorer.Series.min/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#min/1","title":"Explorer.Series.min/1","type":"function"},{"doc":"Multiplies left and right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = 11 .. 20 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , s2 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 11 , 24 , 39 , 56 , 75 , 96 , 119 , 144 , 171 , 200 ] &gt; iex&gt; s1 = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , 2 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 2 , 4 , 6 , 8 , 10 ] &gt;","ref":"Explorer.Series.html#multiply/2","title":"Explorer.Series.multiply/2","type":"function"},{"doc":"Returns the number of unique values in the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . n_distinct ( s ) 2","ref":"Explorer.Series.html#n_distinct/1","title":"Explorer.Series.n_distinct/1","type":"function"},{"doc":"Returns boolean mask of left != right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . not_equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . not_equal ( s , 1 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . not_equal ( s , true ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , &quot;a&quot; ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . not_equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . not_equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , false ) ** (ArgumentError) cannot invoke Explorer.Series.not_equal/2 with mismatched dtypes: string and false.","ref":"Explorer.Series.html#not_equal/2","title":"Explorer.Series.not_equal/2","type":"function"},{"doc":"Returns a boolean mask of left or right , element-wise Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . less ( s1 , 2 ) iex&gt; mask2 = Explorer.Series . greater ( s1 , 2 ) iex&gt; Explorer.Series . or ( mask1 , mask2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , true ] &gt;","ref":"Explorer.Series.html#or/2","title":"Explorer.Series.or/2","type":"function"},{"doc":"Returns a boolean mask with true where the 'peaks' (series max or min, default max) are. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 4 , 1 , 4 ] ) iex&gt; Explorer.Series . peaks ( s ) # Explorer.Series &lt; Polars [ 5 ] boolean [ false , false , true , false , true ] &gt;","ref":"Explorer.Series.html#peaks/2","title":"Explorer.Series.peaks/2","type":"function"},{"doc":"Raises a numeric series to the power of the exponent. Supported dtypes :integer :float Examples iex&gt; s = [ 8 , 16 , 32 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 2.0 ) # Explorer.Series &lt; Polars [ 3 ] float [ 64.0 , 256.0 , 1024.0 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 3 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 8 , 64 , 216 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , - 3.0 ) # Explorer.Series &lt; Polars [ 3 ] float [ 0.125 , 0.015625 , 0.004629629629629629 ] &gt; iex&gt; s = [ 1.0 , 2.0 , 3.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . pow ( 3.0 ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 8.0 , 27.0 ] &gt; iex&gt; s = [ 2.0 , 4.0 , 6.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . pow ( 2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 4.0 , 16.0 , 36.0 ] &gt;","ref":"Explorer.Series.html#pow/2","title":"Explorer.Series.pow/2","type":"function"},{"doc":"Gets the given quantile of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . quantile ( s , 0.2 ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~N[2021-01-01 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ** (ArgumentError) Explorer.Series.quantile/2 not implemented for dtype :boolean. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#quantile/2","title":"Explorer.Series.quantile/2","type":"function"},{"doc":"Element-wise integer division. Supported dtype :integer Returns nil if there is a zero in the right-hand side. Examples iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . quotient ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 5 , 5 , 5 ] &gt; iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . quotient ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 5 , 5 , nil ] &gt; iex&gt; s1 = [ 10 , 12 , 15 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . quotient ( s1 , 3 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#quotient/2","title":"Explorer.Series.quotient/2","type":"function"},{"doc":"Computes the remainder of an element-wise integer division. Supported dtype :integer Returns nil if there is a zero in the right-hand side. Examples iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . remainder ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 0 , 1 , 0 ] &gt; iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . remainder ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 0 , 1 , nil ] &gt; iex&gt; s1 = [ 10 , 11 , 9 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . remainder ( s1 , 3 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 0 ] &gt;","ref":"Explorer.Series.html#remainder/2","title":"Explorer.Series.remainder/2","type":"function"},{"doc":"Reverses the series order. Example iex&gt; s = [ 1 , 2 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . reverse ( s ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#reverse/1","title":"Explorer.Series.reverse/1","type":"function"},{"doc":"Returns a random sample of the series. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. Options replacement - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the series or frac &gt; 1.0. (default: false ) seed - An integer to be used as a random seed. If nil, a random value between 1 and 1e12 will be used. (default: nil) Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 10 , seed : 100 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 72 , 33 , 15 , 4 , 16 , 49 , 23 , 96 , 45 , 47 ] &gt; iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 0.05 , seed : 100 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 68 , 24 , 6 , 8 , 36 ] &gt; iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 7 , seed : 100 , replacement : true ) # Explorer.Series &lt; Polars [ 7 ] integer [ 5 , 1 , 2 , 4 , 5 , 3 , 1 ] &gt; iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 1.2 , seed : 100 , replacement : true ) # Explorer.Series &lt; Polars [ 6 ] integer [ 5 , 1 , 2 , 4 , 5 , 3 ] &gt;","ref":"Explorer.Series.html#sample/3","title":"Explorer.Series.sample/3","type":"function"},{"doc":"Returns the size of the series. In the context of lazy series - using DataFrame.*_with/2 functions -, size/1 is going to count the elements inside the same group. If no group is in use, then size is going to return the length of the series. This behaviour is the same as count/1 for lazy series. Examples iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . size ( s ) 2","ref":"Explorer.Series.html#size/1","title":"Explorer.Series.size/1","type":"function"},{"doc":"Returns the elements at the given indices as a new series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . slice ( s , [ 0 , 2 ] ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;a&quot; , &quot;c&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . slice ( s , 1 .. 2 ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;b&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.Series.html#slice/2","title":"Explorer.Series.slice/2","type":"function"},{"doc":"Returns a slice of the series, with size elements starting at offset . Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , 1 , 2 ) # Explorer.Series &lt; Polars [ 2 ] integer [ 2 , 3 ] &gt; Negative offsets count from the end of the series. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 2 ) # Explorer.Series &lt; Polars [ 2 ] integer [ 3 , 4 ] &gt; If the size would run past the end of the series, the result may be shorter than the size. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 4 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#slice/3","title":"Explorer.Series.slice/3","type":"function"},{"doc":"Sorts the series. Examples iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; s |&gt; Explorer.Series . sort ( ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 3 , 7 , 9 ] &gt;","ref":"Explorer.Series.html#sort/2","title":"Explorer.Series.sort/2","type":"function"},{"doc":"Gets the standard deviation of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . std ( s ) ** (ArgumentError) Explorer.Series.std/1 not implemented for dtype :string. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#std/1","title":"Explorer.Series.std/1","type":"function"},{"doc":"Subtracts right from left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . subtract ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ - 3 , - 3 , - 3 ] &gt; You can also use scalar values on both sides: iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . subtract ( s1 , 2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ - 1 , 0 , 1 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . subtract ( 2 , s1 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 0 , - 1 ] &gt;","ref":"Explorer.Series.html#subtract/2","title":"Explorer.Series.subtract/2","type":"function"},{"doc":"Gets the sum of the series. Supported dtypes :integer :float :boolean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . sum ( s ) 6 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . sum ( s ) 6.0 iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . sum ( s ) 2 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . sum ( s ) ** (ArgumentError) Explorer.Series.sum/1 not implemented for dtype :date. Valid dtypes are [:integer, :float, :boolean].","ref":"Explorer.Series.html#sum/1","title":"Explorer.Series.sum/1","type":"function"},{"doc":"Returns the last N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . tail ( s ) # Explorer.Series &lt; Polars [ 10 ] integer [ 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ] &gt;","ref":"Explorer.Series.html#tail/2","title":"Explorer.Series.tail/2","type":"function"},{"doc":"Takes every n th value in this series, returned as a new series. Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . take_every ( 2 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 1 , 3 , 5 , 7 , 9 ] &gt; If n is bigger than the size of the series, the result is a new series with only the first value of the supplied series. iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . take_every ( 20 ) # Explorer.Series &lt; Polars [ 1 ] integer [ 1 ] &gt;","ref":"Explorer.Series.html#take_every/2","title":"Explorer.Series.take_every/2","type":"function"},{"doc":"Converts a series to an enumerable. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; series |&gt; Explorer.Series . to_enum ( ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_enum/1","title":"Explorer.Series.to_enum/1","type":"function"},{"doc":"Converts a series to a list. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_list ( series ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_list/1","title":"Explorer.Series.to_list/1","type":"function"},{"doc":"Converts a series to a Nx.Tensor.t/0 . Options are passed directly to Nx.tensor/2 . Supported dtypes :float :integer Warning Nx is an optional dependency. You will need to ensure it's installed to use this function. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s ) # Nx.Tensor &lt; s64 [ 3 ] [ 1 , 2 , 3 ] &gt; Tensor options can be passed directly to to_tensor/2 . iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s , names : [ :y ] , type : { :f , 64 } ) # Nx.Tensor &lt; f64 [ y : 3 ] [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#to_tensor/2","title":"Explorer.Series.to_tensor/2","type":"function"},{"doc":"Returns an Explorer.Series where each element is the result of invoking fun on each corresponding element of series . This is an expensive operation meant to enable the use of arbitrary Elixir functions against any backend. The implementation will vary by backend but in most (all?) cases will require converting to an Elixir.List , applying Enum.map/2 , and then converting back to an Explorer.Series . Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;this &quot; , &quot; is&quot; , &quot;great &quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . trim / 1 ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . length / 1 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 4 , 2 , 5 ] &gt;","ref":"Explorer.Series.html#transform/2","title":"Explorer.Series.transform/2","type":"function"},{"doc":"Returns the unique values of the series, but does not maintain order. Faster than distinct/1 . Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . unordered_distinct ( )","ref":"Explorer.Series.html#unordered_distinct/1","title":"Explorer.Series.unordered_distinct/1","type":"function"},{"doc":"Gets the variance of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . var ( s ) ** (ArgumentError) Explorer.Series.var/1 not implemented for dtype :datetime. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#var/1","title":"Explorer.Series.var/1","type":"function"},{"doc":"Calculate the rolling max, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_max ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_max ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 4.0 , 6.0 , 8.0 , 10.0 , 12.0 , 14.0 , 16.0 , 18.0 , 20.0 ] &gt;","ref":"Explorer.Series.html#window_max/3","title":"Explorer.Series.window_max/3","type":"function"},{"doc":"Calculate the rolling mean, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_mean ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 1.5 , 2.0 , 2.5 , 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_mean ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 2.5 , 4.0 , 5.5 , 7.0 , 8.5 , 10.0 , 11.5 , 13.0 , 14.5 ] &gt;","ref":"Explorer.Series.html#window_mean/3","title":"Explorer.Series.window_mean/3","type":"function"},{"doc":"Calculate the rolling min, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_min ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 1 , 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_min ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 ] &gt;","ref":"Explorer.Series.html#window_min/3","title":"Explorer.Series.window_min/3","type":"function"},{"doc":"Calculate the rolling sum, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_sum ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 3 , 6 , 10 , 14 , 18 , 22 , 26 , 30 , 34 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_sum ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 5.0 , 8.0 , 11.0 , 14.0 , 17.0 , 20.0 , 23.0 , 26.0 , 29.0 ] &gt;","ref":"Explorer.Series.html#window_sum/3","title":"Explorer.Series.window_sum/3","type":"function"},{"doc":"","ref":"Explorer.Series.html#t:dtype/0","title":"Explorer.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:lazy_t/0","title":"Explorer.Series.lazy_t/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:t/0","title":"Explorer.Series.t/0","type":"type"},{"doc":"The behaviour for Explorer backends and associated functions. Each backend is a module with DataFrame and Series submodules that match the respective behaviours for each. The default backend is read from the application environment. Currently, the only backend is an in-memory, eager one based on Polars . When alternatives are available, you can use them by configuring your runtime: # config/runtime.exs import Config config :explorer , default_backend : Lib.CustomBackend","ref":"Explorer.Backend.html","title":"Explorer.Backend","type":"module"},{"doc":"Gets the default backend for the current process.","ref":"Explorer.Backend.html#get/0","title":"Explorer.Backend.get/0","type":"function"},{"doc":"Sets the current process default backend to backend . The default backend is stored only in the process dictionary. This means if you start a separate process, such as Task , the default backend must be set on the new process too. Examples iex&gt; Explorer.Backend . put ( Lib.CustomBackend ) Explorer.PolarsBackend iex&gt; Explorer.Backend . get ( ) Lib.CustomBackend","ref":"Explorer.Backend.html#put/1","title":"Explorer.Backend.put/1","type":"function"},{"doc":"The behaviour for DataFrame backends.","ref":"Explorer.Backend.DataFrame.html","title":"Explorer.Backend.DataFrame","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:arrange/2","title":"Explorer.Backend.DataFrame.arrange/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:arrange_with/3","title":"Explorer.Backend.DataFrame.arrange_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:collect/1","title":"Explorer.Backend.DataFrame.collect/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:concat_columns/1","title":"Explorer.Backend.DataFrame.concat_columns/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:concat_rows/1","title":"Explorer.Backend.DataFrame.concat_rows/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:distinct/4","title":"Explorer.Backend.DataFrame.distinct/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:drop_nil/2","title":"Explorer.Backend.DataFrame.drop_nil/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dummies/2","title":"Explorer.Backend.DataFrame.dummies/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_csv/3","title":"Explorer.Backend.DataFrame.dump_csv/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:filter_with/3","title":"Explorer.Backend.DataFrame.filter_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_csv/11","title":"Explorer.Backend.DataFrame.from_csv/11","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ipc/2","title":"Explorer.Backend.DataFrame.from_ipc/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ipc_stream/2","title":"Explorer.Backend.DataFrame.from_ipc_stream/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ndjson/3","title":"Explorer.Backend.DataFrame.from_ndjson/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_parquet/1","title":"Explorer.Backend.DataFrame.from_parquet/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_series/1","title":"Explorer.Backend.DataFrame.from_series/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_tabular/1","title":"Explorer.Backend.DataFrame.from_tabular/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:head/2","title":"Explorer.Backend.DataFrame.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:inspect/2","title":"Explorer.Backend.DataFrame.inspect/2","type":"callback"},{"doc":"Default inspect implementation for backends.","ref":"Explorer.Backend.DataFrame.html#inspect/5","title":"Explorer.Backend.DataFrame.inspect/5","type":"function"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:join/5","title":"Explorer.Backend.DataFrame.join/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:lazy/0","title":"Explorer.Backend.DataFrame.lazy/0","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mask/2","title":"Explorer.Backend.DataFrame.mask/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mutate/3","title":"Explorer.Backend.DataFrame.mutate/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mutate_with/3","title":"Explorer.Backend.DataFrame.mutate_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_rows/1","title":"Explorer.Backend.DataFrame.n_rows/1","type":"callback"},{"doc":"Creates a new DataFrame for a given backend.","ref":"Explorer.Backend.DataFrame.html#new/3","title":"Explorer.Backend.DataFrame.new/3","type":"function"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_longer/6","title":"Explorer.Backend.DataFrame.pivot_longer/6","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_wider/5","title":"Explorer.Backend.DataFrame.pivot_wider/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pull/2","title":"Explorer.Backend.DataFrame.pull/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:rename/3","title":"Explorer.Backend.DataFrame.rename/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:sample/4","title":"Explorer.Backend.DataFrame.sample/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:select/2","title":"Explorer.Backend.DataFrame.select/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/2","title":"Explorer.Backend.DataFrame.slice/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/3","title":"Explorer.Backend.DataFrame.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:summarise_with/3","title":"Explorer.Backend.DataFrame.summarise_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:tail/2","title":"Explorer.Backend.DataFrame.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_csv/4","title":"Explorer.Backend.DataFrame.to_csv/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ipc/3","title":"Explorer.Backend.DataFrame.to_ipc/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ipc_stream/3","title":"Explorer.Backend.DataFrame.to_ipc_stream/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_lazy/1","title":"Explorer.Backend.DataFrame.to_lazy/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ndjson/2","title":"Explorer.Backend.DataFrame.to_ndjson/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_parquet/3","title":"Explorer.Backend.DataFrame.to_parquet/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_rows/2","title":"Explorer.Backend.DataFrame.to_rows/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:column_name/0","title":"Explorer.Backend.DataFrame.column_name/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:df/0","title":"Explorer.Backend.DataFrame.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:dtype/0","title":"Explorer.Backend.DataFrame.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:dtypes/0","title":"Explorer.Backend.DataFrame.dtypes/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:lazy_frame/0","title":"Explorer.Backend.DataFrame.lazy_frame/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:lazy_series/0","title":"Explorer.Backend.DataFrame.lazy_series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:mutate_value/0","title":"Explorer.Backend.DataFrame.mutate_value/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:ok_result/0","title":"Explorer.Backend.DataFrame.ok_result/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:result/1","title":"Explorer.Backend.DataFrame.result/1","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:series/0","title":"Explorer.Backend.DataFrame.series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:t/0","title":"Explorer.Backend.DataFrame.t/0","type":"type"},{"doc":"Represents a lazy dataframe for building query expressions. The LazyFrame is available inside filter_with , mutate_with , and similar. You cannot perform any operation on them except accessing its underlying series.","ref":"Explorer.Backend.LazyFrame.html","title":"Explorer.Backend.LazyFrame","type":"module"},{"doc":"","ref":"Explorer.Backend.LazyFrame.html#t:t/0","title":"Explorer.Backend.LazyFrame.t/0","type":"type"},{"doc":"This is an opaque implementation of a Series. It represents an operation with its arguments.","ref":"Explorer.Backend.LazySeries.html","title":"Explorer.Backend.LazySeries","type":"module"},{"doc":"","ref":"Explorer.Backend.LazySeries.html#t:t/0","title":"Explorer.Backend.LazySeries.t/0","type":"type"},{"doc":"The behaviour for series backends.","ref":"Explorer.Backend.Series.html","title":"Explorer.Backend.Series","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.Series.html#c:add/2","title":"Explorer.Backend.Series.add/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:all_equal/2","title":"Explorer.Backend.Series.all_equal/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:argsort/2","title":"Explorer.Backend.Series.argsort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_and/2","title":"Explorer.Backend.Series.binary_and/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_or/2","title":"Explorer.Backend.Series.binary_or/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cast/2","title":"Explorer.Backend.Series.cast/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:coalesce/2","title":"Explorer.Backend.Series.coalesce/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:concat/2","title":"Explorer.Backend.Series.concat/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:count/1","title":"Explorer.Backend.Series.count/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_max/2","title":"Explorer.Backend.Series.cumulative_max/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_min/2","title":"Explorer.Backend.Series.cumulative_min/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_sum/2","title":"Explorer.Backend.Series.cumulative_sum/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:distinct/1","title":"Explorer.Backend.Series.distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:divide/2","title":"Explorer.Backend.Series.divide/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:dtype/1","title":"Explorer.Backend.Series.dtype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:eq/2","title":"Explorer.Backend.Series.eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fetch!/2","title":"Explorer.Backend.Series.fetch!/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fill_missing/2","title":"Explorer.Backend.Series.fill_missing/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:first/1","title":"Explorer.Backend.Series.first/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:from_list/2","title":"Explorer.Backend.Series.from_list/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt/2","title":"Explorer.Backend.Series.gt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt_eq/2","title":"Explorer.Backend.Series.gt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:head/2","title":"Explorer.Backend.Series.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:inspect/2","title":"Explorer.Backend.Series.inspect/2","type":"callback"},{"doc":"Default inspect implementation for backends.","ref":"Explorer.Backend.Series.html#inspect/5","title":"Explorer.Backend.Series.inspect/5","type":"function"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_nil/1","title":"Explorer.Backend.Series.is_nil/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_not_nil/1","title":"Explorer.Backend.Series.is_not_nil/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:last/1","title":"Explorer.Backend.Series.last/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt/2","title":"Explorer.Backend.Series.lt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt_eq/2","title":"Explorer.Backend.Series.lt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mask/2","title":"Explorer.Backend.Series.mask/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:max/1","title":"Explorer.Backend.Series.max/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mean/1","title":"Explorer.Backend.Series.mean/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:median/1","title":"Explorer.Backend.Series.median/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:memtype/1","title":"Explorer.Backend.Series.memtype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:min/1","title":"Explorer.Backend.Series.min/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:multiply/2","title":"Explorer.Backend.Series.multiply/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:n_distinct/1","title":"Explorer.Backend.Series.n_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:neq/2","title":"Explorer.Backend.Series.neq/2","type":"callback"},{"doc":"Create a new Series .","ref":"Explorer.Backend.Series.html#new/2","title":"Explorer.Backend.Series.new/2","type":"function"},{"doc":"","ref":"Explorer.Backend.Series.html#c:peaks/2","title":"Explorer.Backend.Series.peaks/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:pow/2","title":"Explorer.Backend.Series.pow/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quantile/2","title":"Explorer.Backend.Series.quantile/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quotient/2","title":"Explorer.Backend.Series.quotient/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:remainder/2","title":"Explorer.Backend.Series.remainder/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:reverse/1","title":"Explorer.Backend.Series.reverse/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sample/4","title":"Explorer.Backend.Series.sample/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:size/1","title":"Explorer.Backend.Series.size/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/2","title":"Explorer.Backend.Series.slice/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/3","title":"Explorer.Backend.Series.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sort/2","title":"Explorer.Backend.Series.sort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:std/1","title":"Explorer.Backend.Series.std/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:subtract/2","title":"Explorer.Backend.Series.subtract/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sum/1","title":"Explorer.Backend.Series.sum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:tail/2","title":"Explorer.Backend.Series.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take_every/2","title":"Explorer.Backend.Series.take_every/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_enum/1","title":"Explorer.Backend.Series.to_enum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_list/1","title":"Explorer.Backend.Series.to_list/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:transform/2","title":"Explorer.Backend.Series.transform/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:unordered_distinct/1","title":"Explorer.Backend.Series.unordered_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:var/1","title":"Explorer.Backend.Series.var/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_max/3","title":"Explorer.Backend.Series.window_max/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_mean/3","title":"Explorer.Backend.Series.window_mean/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_min/3","title":"Explorer.Backend.Series.window_min/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_sum/3","title":"Explorer.Backend.Series.window_sum/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#t:df/0","title":"Explorer.Backend.Series.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:dtype/0","title":"Explorer.Backend.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:lazy_s/0","title":"Explorer.Backend.Series.lazy_s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:s/0","title":"Explorer.Backend.Series.s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:t/0","title":"Explorer.Backend.Series.t/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:valid_types/0","title":"Explorer.Backend.Series.valid_types/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:window_option/0","title":"Explorer.Backend.Series.window_option/0","type":"type"},{"doc":"The Explorer backend for Polars.","ref":"Explorer.PolarsBackend.html","title":"Explorer.PolarsBackend","type":"module"},{"doc":"","ref":"exploring_explorer.html","title":"Ten Minutes to Explorer","type":"extras"},{"doc":"Explorer is a dataframe library for Elixir. A dataframe is a common data structure used in data analysis. It is a two-dimensional table composed of columns and rows similar to a SQL table or a spreadsheet. Explorer's aim is to provide a simple and powerful API for manipulating dataframes. It takes influences mainly from the tidyverse , but if you've used other dataframe libraries like pandas you shouldn't have too much trouble working with Explorer. This document is meant to give you a crash course in using Explorer. More in-depth documentation can be found in the relevant sections of the docs. We strongly recommend you run this livebook locally so you can see the outputs and play with the inputs!","ref":"exploring_explorer.html#introduction","title":"Ten Minutes to Explorer - Introduction","type":"extras"},{"doc":"Connect to a Mix project with Explorer installed or: Mix . install ( [ { :explorer , &quot;~&gt; 0.3.1&quot; } , { :kino , &quot;~&gt; 0.4.1&quot; } ] )","ref":"exploring_explorer.html#installation","title":"Ten Minutes to Explorer - Installation","type":"extras"},{"doc":"Data can be read from delimited files (like CSV), NDJSON, Parquet, and the Arrow IPC (feather) format. You can also load in data from a map or keyword list of columns with Explorer.DataFrame.new/1 . For CSV, your 'usual suspects' of options are available: delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A keyword list of [column_name: dtype] . If a type is not specified for a column, it is imputed from the first 1000 rows. (default: [] ) header - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: nil ) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) columns - A list of column names to keep. If present, only these columns are read into the dataframe. (default: nil ) Explorer also has multiple example datasets built in, which you can load from the Explorer.Datasets module like so: df = Explorer.Datasets . fossil_fuels ( ) You'll notice that the output looks slightly different than many dataframe libraries. Explorer takes inspiration on this front from glimpse in R. A benefit to this approach is that you will rarely need to elide columns. If you'd like to see a table with your data, we've got you covered there too. Explorer.DataFrame . table ( df ) Writing files is very similar to reading them. The options are a little more limited: header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) First, let's add some useful aliases: alias Explorer.DataFrame alias Explorer.Series And then write to a file of your choosing: input = Kino.Input . text ( &quot;Filename&quot; ) filename = Kino.Input . read ( input ) DataFrame . to_csv ( df , filename )","ref":"exploring_explorer.html#reading-and-writing-data","title":"Ten Minutes to Explorer - Reading and writing data","type":"extras"},{"doc":"Explorer , like Polars , works up from the concept of a Series . In many ways, you can think of a dataframe as a row-aligned map of Series . These are like vectors in R or series in Pandas. For simplicity, Explorer uses the following Series dtypes : :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Series can be constructed from Elixir basic types. For example: s1 = Series . from_list ( [ 1 , 2 , 3 ] ) s2 = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) s3 = Series . from_list ( [ ~D[2011-01-01] , ~D[1965-01-21] ] ) You'll notice that the dtype and size of the Series are at the top of the printed value. You can get those programmatically as well. Series . dtype ( s3 ) Series . size ( s3 ) And the printed values max out at 50: 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series are also nullable. s = Series . from_list ( [ 1.0 , 2.0 , nil , nil , 5.0 ] ) And you can fill in those missing values using one of the following strategies: :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Series . fill_missing ( s , :forward ) In the case of mixed numeric types (i.e. integers and floats), Series will downcast to a float: Series . from_list ( [ 1 , 2.0 ] ) In all other cases, Series must all be of the same dtype or else you'll get an ArgumentError . Series . from_list ( [ 1 , 2 , 3 , &quot;a&quot; ] ) One of the goals of Explorer is useful error messages . If you look at the error above, you get: Cannot make a series from mismatched types. Type of &quot;a&quot; does not match inferred dtype integer. Hopefully this makes abundantly clear what's going on. Series also implements the Access protocol. You can slice and dice in many ways: s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) s [ 1 ] s [ - 1 ] s [ 0 .. 4 ] s [ [ 0 , 4 , 4 ] ] And of course, you can convert back to an Elixir list. Series . to_list ( s ) Explorer supports comparisons. s = 1 .. 11 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) s1 = 11 .. 1 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series . equal ( s , s1 ) Series . equal ( s , 5 ) Series . not_equal ( s , 10 ) Series . greater_equal ( s , 4 ) And arithmetic. Series . add ( s , s1 ) Series . subtract ( s , 4 ) Series . multiply ( s , s1 ) Remember those helpful errors? We've tried to add those throughout. So if you try to do arithmetic with mismatching dtypes: s = Series . from_list ( [ 1 , 2 , 3 ] ) s1 = Series . from_list ( [ 1.0 , 2.0 , 3.0 ] ) Series . add ( s , s1 ) Just kidding! Integers and floats will downcast to floats. Let's try again: s = Series . from_list ( [ 1 , 2 , 3 ] ) s1 = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) Series . add ( s , s1 ) You can flip them around. s = Series . from_list ( [ 1 , 2 , 3 , 4 ] ) Series . reverse ( s ) And sort. 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Enum . shuffle ( ) |&gt; Series . from_list ( ) |&gt; Series . sort ( ) Or argsort. s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Enum . shuffle ( ) |&gt; Series . from_list ( ) ids = Series . argsort ( s ) Which you can pass to Explorer.Series.slice/2 if you want the sorted values. Series . slice ( s , ids ) You can calculate cumulative values. s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series . cumulative_sum ( s ) Or rolling ones. Series . window_sum ( s , 4 ) You can count and list unique values. s = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) Series . distinct ( s ) Series . n_distinct ( s ) And you can even get a dataframe showing the counts for each distinct value. Series . count ( s )","ref":"exploring_explorer.html#working-with-series","title":"Ten Minutes to Explorer - Working with Series","type":"extras"},{"doc":"A DataFrame is really just a collection of Series of the same size. Which is why you can create a DataFrame from a Keyword list. DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) Similarly to Series , the Inspect implementation prints some info at the top and to the left. At the top we see the shape of the dataframe (rows and columns) and then for each column we see the name, dtype, and first five values. We can see a bit more from that built-in dataset we loaded in earlier. df You will also see grouping information there, but we'll get to that later. You can get the info yourself directly: DataFrame . names ( df ) DataFrame . dtypes ( df ) DataFrame . shape ( df ) { DataFrame . n_rows ( df ) , DataFrame . n_columns ( df ) } We can grab the head. DataFrame . head ( df ) Or the tail. Let's get a few more values from the tail. DataFrame . tail ( df , 10 ) Select Let's jump right into it. We can select columns pretty simply. DataFrame . select ( df , [ &quot;year&quot; , &quot;country&quot; ] ) But Elixir gives us some superpowers. In R there's tidy-select . I don't think we need that in Elixir. Anywhere in Explorer where you need to pass a list of column names, you can also execute a filtering callback on the column names. It's just an anonymous function passed to df |&gt; DataFrame.names() |&gt; Enum.filter(callback_here) . DataFrame . select ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) Want all but some columns? DataFrame.select/3 takes :keep or :drop as the last arg. It just defaults to :keep . DataFrame . select ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) , :drop ) Filter The next verb we'll look at is filter . You can use the filter_with function to pass anonymous functions: DataFrame . filter_with ( df , &amp; Series . equal ( &amp;1 [ &quot;country&quot; ] , &quot;AFGHANISTAN&quot; ) ) Using complex filters is also possible: filtered_df = DataFrame . filter_with ( df , fn ldf -&gt; ldf [ &quot;country&quot; ] |&gt; Series . equal ( &quot;ALGERIA&quot; ) |&gt; Series . and ( Series . greater ( ldf [ &quot;year&quot; ] , 2012 ) ) end ) The code above is going to use a virtual representation of the data frame that we call a &quot;lazy frame&quot;. With lazy frames you don't have access to the series contents, but every operation will be optimized and run only once. Remember those helpful error messages? DataFrame . filter_with ( df , &amp; Series . equal ( &amp;1 [ &quot;cuontry&quot; ] , &quot;AFGHANISTAN&quot; ) ) Mutate A common task in data analysis is to add columns or change existing ones. Mutate is a handy verb. DataFrame . mutate_with ( df , &amp; [ new_column : Series . add ( &amp;1 [ &quot;solid_fuel&quot; ] , &amp;1 [ &quot;cement&quot; ] ) ] ) Did you catch that? You can pass in new columns as keyword arguments. It also works to transform existing columns. DataFrame . mutate_with ( df , fn df -&gt; [ gas_fuel : Series . cast ( df [ &quot;gas_fuel&quot; ] , :float ) , gas_and_liquid_fuel : Series . add ( df [ &quot;gas_fuel&quot; ] , df [ &quot;liquid_fuel&quot; ] ) ] end ) DataFrame.mutate/2 is flexible though. You may not always want to use keyword arguments. Given that column names are String.t() , it may make more sense to use a map. DataFrame . mutate_with ( df , &amp; %{ &quot;gas_fuel&quot; =&gt; Series . subtract ( &amp;1 [ &quot;gas_fuel&quot; ] , 10 ) } ) DataFrame.transmute/2 , which is DataFrame.mutate/2 that only retains the specified columns, is forthcoming. Arrange Sorting the dataframe is pretty straightforward. DataFrame . arrange ( df , &quot;year&quot; ) But it comes with some tricks up its sleeve. DataFrame . arrange ( df , asc : &quot;total&quot; , desc : &quot;year&quot; ) Sort operations happen left to right. And keyword list args permit specifying the direction. Distinct Okay, as expected here too. Very straightforward. DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] ) You can specify whether to keep the other columns as well. DataFrame . distinct ( df , [ &quot;country&quot; ] , keep_all : true ) Rename Rename can take either a list of new names or a callback that is passed to Enum.map/2 against the names. You can also use a map or keyword args to rename specific columns. DataFrame . rename ( df , year : &quot;year_test&quot; ) DataFrame . rename_with ( df , &amp; ( &amp;1 &lt;&gt; &quot;_test&quot; ) ) Dummies This is fun! We can get dummy variables for unique values. DataFrame . dummies ( df , [ &quot;year&quot; ] ) DataFrame . dummies ( df , [ &quot;country&quot; ] ) Sampling Random samples can give us a percent or a specific number of samples, with or without replacement, and the function is seedable. DataFrame . sample ( df , 10 ) DataFrame . sample ( df , 0.4 ) Trying for those helpful error messages again. DataFrame . sample ( df , 10000 ) DataFrame . sample ( df , 10000 , replacement : true ) Pull and slice Slicing and dicing can be done with the Access protocol or with explicit pull/slice/take functions. df [ &quot;year&quot; ] DataFrame . pull ( df , &quot;year&quot; ) df [ [ &quot;year&quot; , &quot;country&quot; ] ] DataFrame . slice ( df , [ 1 , 20 , 50 ] ) Negative offsets work for slice! DataFrame . slice ( df , - 10 , 5 ) DataFrame . slice ( df , 10 , 5 ) Slice also works with ranges: DataFrame . slice ( df , 12 .. 42 ) Pivot We can pivot_longer/3 and pivot_wider/4 . These are inspired by tidyr . There are some shortcomings in pivot_wider/4 related to polars . The values_from column must be a numeric type. DataFrame . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_columns : &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) DataFrame . pivot_wider ( df , &quot;country&quot; , &quot;total&quot; , id_columns : [ &quot;year&quot; ] ) Let's make those names look nicer! tidy_names = fn name -&gt; name |&gt; String . downcase ( ) |&gt; String . replace ( ~r/ \\s / , &quot; &quot; ) |&gt; String . replace ( ~r/[^A-Za-z \\s ]/ , &quot;&quot; ) |&gt; String . replace ( &quot; &quot; , &quot;_&quot; ) end df |&gt; DataFrame . pivot_wider ( &quot;country&quot; , &quot;total&quot; , id_columns : [ &quot;year&quot; ] ) |&gt; DataFrame . rename_with ( tidy_names ) Joins Joining is fast and easy. You can specify the columns to join on and how to join. Polars even supports cartesian (cross) joins, so Explorer does too. df1 = DataFrame . select ( df , [ &quot;year&quot; , &quot;country&quot; , &quot;total&quot; ] ) df2 = DataFrame . select ( df , [ &quot;year&quot; , &quot;country&quot; , &quot;cement&quot; ] ) DataFrame . join ( df1 , df2 ) df3 = df |&gt; DataFrame . select ( [ &quot;year&quot; , &quot;cement&quot; ] ) |&gt; DataFrame . slice ( 0 , 500 ) DataFrame . join ( df1 , df3 , how : :left ) Grouping Explorer supports groupby operations. They're limited based on what's possible in Polars, but they do most of what you need to do. grouped = DataFrame . group_by ( df , [ &quot;country&quot; ] ) Notice that the Inspect call now shows groups as well as rows and columns . You can, of course, get them explicitly. DataFrame . groups ( grouped ) And you can ungroup explicitly. DataFrame . ungroup ( grouped ) But what we care about the most is aggregating! Let's see which country has the max per_capita value. grouped |&gt; DataFrame . summarise ( per_capita : [ :max ] ) |&gt; DataFrame . arrange ( desc : :per_capita_max ) Qatar it is. You can use the following aggregations: :min - Take the minimum value within the group. See Explorer.Series.min/1 . :max - Take the maximum value within the group. See Explorer.Series.max/1 . :sum - Take the sum of the series within the group. See Explorer.Series.sum/1 . :mean - Take the mean of the series within the group. See Explorer.Series.mean/1 . :median - Take the median of the series within the group. See Explorer.Series.median/1 . :first - Take the first value within the group. See Explorer.Series.first/1 . :last - Take the last value within the group. See Explorer.Series.last/1 . :count - Count the number of rows per group. :n_unique - Count the number of unique rows per group. The API is similar to mutate : you can use keyword args or a map and specify aggregations to use. grouped |&gt; DataFrame . summarise ( per_capita : [ :max , :min ] , total : [ :min ] ) Speaking of mutate , it's 'group-aware'. As are arrange , distinct , and n_rows . DataFrame . arrange ( grouped , desc : :total ) In case you need more complex operations, like calculations inside groups, you can use the more flexible Explorer.DataFrame.summarise_with/2 function. DataFrame . summarise_with ( grouped , fn df -&gt; max = Series . max ( df [ &quot;per_capita&quot; ] ) [ per_capita_max : max , greater_than_9 : Series . greater ( max , 9.0 ) ] end ) |&gt; DataFrame . arrange ( desc : :per_capita_max ) That's it! And not. This is certainly not exhaustive, but I hope it gives you a good idea of what can be done and what the 'flavour' of the API is like. I'd love contributions and issues raised where you find them!","ref":"exploring_explorer.html#working-with-dataframes","title":"Ten Minutes to Explorer - Working with DataFrames","type":"extras"},{"doc":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","ref":"changelog.html","title":"Changelog","type":"extras"},{"doc":"Fixed Define multiply inside *_with operations. Fix column types in several operations, such as n_distinct .","ref":"changelog.html#0-3-1-2022-09-09","title":"Changelog - [0.3.1] - 2022-09-09","type":"extras"},{"doc":"Added Add DataFrame.concat_columns/1 and DataFrame.concat_columns/2 for horizontally stacking dataframes. Add compression as an option to write parquet files. Add count metadata to DataFrame table reader. Add DataFrame.filter_with/2 , DataFrame.summarise_with/2 , DataFrame.mutate_with/2 and DataFrame.arrange_with/2 . They all accept a DataFrame and a function, and they all work with a new concept called &quot;lazy series&quot;. Lazy Series is an opaque representation of a series that can be used to perform complex operations without pulling data from the series. This is faster than using masks. There is no big difference from the API perspective compared to the functions that were accepting callbacks before (eg. filter/2 and the new filter_with/2 ), with the exception being DataFrame.summarise_with/2 that now accepts a lot more operations. Changed Bump version requirement of the table dependency to ~&gt; 0.1.2 , and raise for non-tabular values. Normalize how columns are handled. This changes some functions to accept one column or a list of columns, ranges, indexes and callbacks selecting columns. Rename DataFrame.filter/2 to DataFrame.mask/2 . Rename Series.filter/2 to Series.mask/2 . Rename take/2 from both Series and DataFrame to slice/2 . slice/2 now they accept ranges as well. Raise an error if DataFrame.pivot_wider/4 has float columns as IDs. This is because we can´t properly compare floats. Change DataFrame.distinct/2 to accept columns as argument instead of receiving it as option. Fixed Ensure that we can compare boolean series in functions like Series.equal/2 . Fix rename of columns after summarise. Fix inspect of float series containing NaN or Infinity values. They are represented as atoms. Deprecated Deprecate DataFrame.filter/2 with a callback in favor of DataFrame.filter_with/2 .","ref":"changelog.html#v0-3-0-2022-09-01","title":"Changelog - [v0.3.0] - 2022-09-01","type":"extras"},{"doc":"Added Consistently support ranges throughout the columns API Support negative indexes throughout the columns API Integrate with the table package Add Series.to_enum/1 for lazily traversing the series Add Series.coalesce/1 and Series.coalesce/2 for finding the first non-null value in a list of series Changed Series.length/1 is now Series.size/1 in keeping with Elixir idioms Nx is now an optional dependency Minimum Elixir version is now 1.13 DataFrame.to_map/2 is now DataFrame.to_columns/2 and DataFrame.to_series/2 Rustler is now an optional dependency read_ and write_ IO functions are now from_ and to_ to_binary is now dump_csv Now uses polars 's &quot;simd&quot; feature Now uses polars 's &quot;performant&quot; feature Explorer.default_backend/0 is now Explorer.Backend.get/0 Explorer.default_backend/1 is now Explorer.Backend.put/1 Series.cum_* functions are now Series.cumulative_* to mirror Nx Series.rolling_* functions are now Series.window_* to mirror Nx reverse? is now an option instead of an argument in Series.cumulative_* functions DataFrame.from_columns/2 and DataFrame.from_rows/2 is now DataFrame.new/2 Rename &quot;col&quot; to &quot;column&quot; throughout the API Remove &quot;with_&quot; prefix in options throughout the API DataFrame.table/2 accepts options with :limit instead of single integer rename/2 no longer accepts a function, use rename_with/2 instead rename_with/3 now expects the function as the last argument Fixed Explorer now works on Linux with musl","ref":"changelog.html#v0-2-0-2022-06-22","title":"Changelog - v0.2.0 - 2022-06-22","type":"extras"},{"doc":"Security Updated Rust dependencies to address Dependabot security alerts: 1 , 2 , 3","ref":"changelog.html#v0-1-1-2022-04-27","title":"Changelog - v0.1.1 - 2022-04-27","type":"extras"},{"doc":"First release.","ref":"changelog.html#v0-1-0-2022-04-26","title":"Changelog - v0.1.0 - 2022-04-26","type":"extras"}]